#LyX 1.6.0 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\begin_preamble
\definecolor{standardCodeBgColor}{rgb}{0.9,0.9,0.9}
\end_preamble
\options html
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 0
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\branch HTML
\selected 0
\color #faf0e6
\end_branch
\branch PDF
\selected 0
\color #faf0e6
\end_branch
\secnumdepth 5
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "backgroundcolor={\color{standardCodeBgColor}},breaklines=true,extendedchars=true,language=Java"
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset Branch HTML
status collapsed

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
usepackage{tex4ht}
\end_layout

\begin_layout Plain Layout


\backslash
Css{
\end_layout

\begin_layout Plain Layout

.crosslinks img{ 
\end_layout

\begin_layout Plain Layout

border-style: none;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

div.lstlisting{
\end_layout

\begin_layout Plain Layout

background-color:lightgray;
\end_layout

\begin_layout Plain Layout

border-width:1px;
\end_layout

\begin_layout Plain Layout

border-color:black;
\end_layout

\begin_layout Plain Layout

border-style:solid;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

dl.description{
\end_layout

\begin_layout Plain Layout

background-color:lightyellow;
\end_layout

\begin_layout Plain Layout

border-width:1px;
\end_layout

\begin_layout Plain Layout

border-color:black;
\end_layout

\begin_layout Plain Layout

border-style:dashed;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

.sectionHead{
\end_layout

\begin_layout Plain Layout

font-size:2em;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

.subsectionHead{
\end_layout

\begin_layout Plain Layout

font-size:1.8em;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

.subsubsectionHead{
\end_layout

\begin_layout Plain Layout

font-size:1.6em;
\end_layout

\begin_layout Plain Layout

counter-reset: paragraph;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

.paragraphHead{
\end_layout

\begin_layout Plain Layout

font-size:1.4em;
\end_layout

\begin_layout Plain Layout

counter-reset: subparagraph;
\end_layout

\begin_layout Plain Layout

content: counter(paragraph);
\end_layout

\begin_layout Plain Layout

font-style:underline;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

.subparagraphHead{
\end_layout

\begin_layout Plain Layout

font-size:1.2em;
\end_layout

\begin_layout Plain Layout

content: counter(subparagraph);
\end_layout

\begin_layout Plain Layout

font-style:italic;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

p{ 
\end_layout

\begin_layout Plain Layout

font-size:1em;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
Configure{crosslinks}{}{}
\end_layout

\begin_layout Plain Layout

{
\backslash
Picture[next]{cssimages/go-next.png class="nextarrow"}}
\end_layout

\begin_layout Plain Layout

{
\backslash
Picture[previous]{cssimages/go-previous.png class="previousarrow"}}
\end_layout

\begin_layout Plain Layout

{}{}{}{
\backslash
Picture[up]{cssimages/go-top.png class="uparrow"}}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Title
Tatami Programmatic Documentation
\end_layout

\begin_layout Date
December 2008
\end_layout

\begin_layout Author
Henri Darmet, Vianney Grassaud, Ronan Dunklau
\end_layout

\begin_layout Abstract
This document explains how to use in a GWT application the Tatami components.
 Each component is presented in details, including its APIs.
 The implementation details of those components are outside the scope of
 this document, except when they are relevant from a user view point.
 You can also take an eye on the source code of the TatamiDemo-1.1 project.
 In this project, most of the Tatami components are used and expose their
 main features.
 
\end_layout

\begin_layout Standard
You should also take a look to the Tatami TestPages project.
 This project is used to automatically test Tatami using HTMLUnit.
 Newer widgets are demonstrated in this project.
\end_layout

\begin_layout Standard
You also may take a look to the Tatami Player project, which uses some Tatami
 Widgets to demonstrate how easy it can be to create a simple application.
 
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Installation
\end_layout

\begin_layout Section
Simple Installation
\end_layout

\begin_layout Standard
Tatami is released as a single Jar (tatami.jar) which contains all the resources
 necessary: code Java, files of configurations, files CSS, images and JavaScript
 code.
 To use Tatami, it is enough to add this jar in the classpath of your applicatio
n and to insert in the file of configuration of your module (.gwt.xml) the
 following line:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=XML"
inline false
status open

\begin_layout Plain Layout

<inherits name="com.objetdirect.tatami.Tatami"/>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You do not have to choose import the dojo stylesheets, nor add the corresponding
 class in your marku
\end_layout

\begin_layout Standard
p: the theme package takes care of that for yourself! 
\end_layout

\begin_layout Section
Custom Installation
\end_layout

\begin_layout Standard
The Simple Installation (Tatami module) contains all the scripts used for
 Tatami, including the base Dojo release and Yui.
 This has two side-effects : If you just use Dojo, or YUI, you will have
 to download both.
 If you use Dojo, you will use the base release, loading all the required
 dojo modules asynchronously as you need it.
\end_layout

\begin_layout Standard
That is why Tatami offers the possibility to import only what you want,
 and use an optimized build of dojo if you need it.
 You can do so importing smaller Tatami modules than Tatami itself.
 These modules are:
\end_layout

\begin_layout Description
Tatami_Base: all others modules inherit this one, so you do not have to
 include it
\end_layout

\begin_layout Description
Tatami_YUI: only loads YUI.
 Use this only if you use YUI widgets (such as Tatami DragAndDropPanel)
 
\end_layout

\begin_layout Description
Tatami_DojoBase: only loads dojo core, and then load all other modules asynchron
ously.
 This is the recommended module if you do not use Tatami intensively.
 
\end_layout

\begin_layout Description
Tatami_DojoCharting: loads dojo core and an optimized build of its charting
 package, so it does not have to be loaded asynchronously.
 Recommended if you use Tatami’s charting facilities
\end_layout

\begin_layout Description
Tatami_DojoGFX: same principle as Tatami_DojoCharting, applied to GFX package
 
\end_layout

\begin_layout Description
Tatami_DojoWidgets: same principle as Tatami_DojoCharting, applied to the
 
\end_layout

\begin_layout Description
widgets.
 Loads all dojo widgets used by Tatami.
 Recommended if you use most of Tatami Dojo Widgets.
 
\end_layout

\begin_layout Description
Tatami_DojoAll: Import DojoGFX, DojoWidgets and DojoCharting at load time.
 
\end_layout

\begin_layout Standard
For example, if you want to use the DojoWidgets optimization : 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true,language=XML"
inline false
status open

\begin_layout Plain Layout

<module>
\end_layout

\begin_layout Plain Layout

	<inherits name="com.google.gwt.user.User"/>
\end_layout

\begin_layout Plain Layout

	<inherits name="com.objetdirect.tatami.Tatami_DojoWidget"/>
\end_layout

\begin_layout Plain Layout

	<entry-point class="mymodule.client.Module"/>
\end_layout

\begin_layout Plain Layout

</module>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, when deploying for a production environment, you should use your
 custom dojo build, including only what you actually need.
 
\end_layout

\begin_layout Standard
Then, you can choose to use another theme for tatami.
 For now, the three official themes from dojo are available : tundra (as
 the default one), soria and nihilo.
\end_layout

\begin_layout Standard
To use one or another, just import the corresponding module.
 For example, if you w
\end_layout

\begin_layout Standard
ant to use the soria them with the above configuration :
\begin_inset listings
lstparams "extendedchars=true,language=XML"
inline false
status open

\begin_layout Plain Layout

<module>
\end_layout

\begin_layout Plain Layout

	<inherits name="com.google.gwt.user.User"/>
\end_layout

\begin_layout Plain Layout

	<inherits name="com.objetdirect.tatami.Tatami_DojoWidget"/>
\end_layout

\begin_layout Plain Layout

	<inherits name="com.objetdirect.tatami.theme.Soria"/>
\end_layout

\begin_layout Plain Layout

	<entry-point class="mymodule.client.Module"/>
\end_layout

\begin_layout Plain Layout

</module>
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Widgets
\end_layout

\begin_layout Section
Layout Widgets
\end_layout

\begin_layout Section
User Input Widgets
\end_layout

\begin_layout Subsection
FishEye
\end_layout

\begin_layout Standard
The FishEye is a dynamic tool bar.
 The size of icons on the tool bar varies according to the mouse position
 with respect to the icon.
 The icons are active ones, in a sense they can be associated with a command
 which will be triggered when the icon is activated.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/fisheye_preview.png

\end_inset


\end_layout

\begin_layout Subsubsection
Create the FishEye component
\end_layout

\begin_layout Standard
Before being able to create a FishEye instance, the appropriate import declarati
on should be added to the class:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true,language=Java"
inline false
status open

\begin_layout Plain Layout

import com.objetdirect.tatami.client.FishEye;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is then possible to create an instance of the FishEye.
 The simplest and most common way is to use the default constructor:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

FishEye fe = new FishEye(); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will create a FishEye component with the default behavior: the icon
 sizes will vary between 50 and 200 pixels, and they will be laid out horizontal
ly.
 When the icons are magnified by the mouse proximity, they stay centered
 on the FishEye.
 The icon title appears just below the icon.
\end_layout

\begin_layout Standard
This behavior can be differentiated by using one of the two remaining constructo
rs with parameters.
\end_layout

\begin_layout Standard
The first constructor has only the most frequently used parameters: the
 minimum and maximum icon sizes as well as the component orientation.
 For instance, here is the creation of a vertical FishEye with icon sizes
 varying from 40x40 pixels to 400x200 pixels:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

FishEye fe = new FishEye(40, 40, 400, 200, FishEye.VERTICAL); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And the corresponding result:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/fisheye_first_example.png

\end_inset


\end_layout

\begin_layout Standard
The last constructor allows the specification of all available Dojo parameters.
 It is therefore slightly more complex to use, some parameters are even
 not completely understood by the Tatami team!
\end_layout

\begin_layout Standard
Those parameters are (in order):
\end_layout

\begin_layout Description
itemWidth: width of menu item (in pixels) in it's dormant state (when the
 mouse is far away) 
\end_layout

\begin_layout Description
itemHeight: height of menu item (in pixels) in it's dormant state (when
 the mouse is far away) 
\end_layout

\begin_layout Description
itemMaxWidth: width of menu item (in pixels) in it's fully enlarged state
 (when the mouse is directly over it)
\end_layout

\begin_layout Description
itemMaxHeight: height of menu item (in pixels) in it's fully enlarged state
 (when the mouse is directly over it)
\end_layout

\begin_layout Description
orientation: orientation of the icons bar : FishEye.VERTICAL et FishEye.HORIZONTAL.
 
\end_layout

\begin_layout Description
effectUnits: controls how much reaction the menu makes, relative to the
 distance of the mouse from the menu
\end_layout

\begin_layout Description
itemPadding: padding (in pixels) between each menu item
\end_layout

\begin_layout Description
attachEdge: Controls the border that the menu items don't expand past; for
 example, if set to "top", then the menu items will drop downwards as they
 expand.
 FishEye.CENTER, FishEye.TOP, FishEye.BOTTOM, FishEye.LEFT, FishEye.LEFT, FishEye.RIGH
T.
\end_layout

\begin_layout Description
labelEdge: Controls were the labels show up in relation to the menu item
 icons : FishEye.CENTER, FishEye.TOP, FishEye.BOTTOM, FishEye.LEFT, FishEye.LEFT,
 FishEye.RIGHT.
 
\end_layout

\begin_layout Description
conservativeTrigger :if true, don't start enlarging menu items until mouse
 is over an image; if false, start enlarging menu items as the mouse moves
 near them.
 
\end_layout

\begin_layout Standard
Here is an example of the use of this constructor:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

FishEye fe = new FishEye(40, 40, 200, 400, FishEye.HORIZONTAL, 1, 0, FishEye.TOP,
 FishEye.RIGHT, true);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And here is the corresponding result:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/fisheye_second_example.png

\end_inset


\end_layout

\begin_layout Standard
Instantiating the FishEye is not enough by itself to have it displayed.
 It has to be hanged in the GWT widget tree.
 
\end_layout

\begin_layout Standard
For a FishEye positioned on the upper left corner of the page body, you
 should write:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

RootPanel rootPanel = RootPanel.get(); rootPanel.add(fe, 50, 50); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Take attention to have some margin around the FishEye (50 pixels in both
 dimensions in the example), otherwise the icons could appear partly outside
 the page.
\end_layout

\begin_layout Subsubsection
Adding and removing icons
\end_layout

\begin_layout Standard
A FishEye with no icon is useless.
 The add method can be used to add new icons to the component.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true,language=Java"
inline false
status open

\begin_layout Plain Layout

Command cmd = new Command() {
\end_layout

\begin_layout Plain Layout

	public void execute() {};
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

fe.add("amor.png", "drap'n'drop", cmd);
\end_layout

\end_inset

This method requires three parameters:
\end_layout

\begin_layout Description
icon: The URL of the icon to be displayed, as a String,
\end_layout

\begin_layout Description
caption: The title which is displayed near the icon 
\end_layout

\begin_layout Description
command: A command implementation (com.google.gwt.user.client.Command) that will
 be activated when the icon will be selected.
 .
\end_layout

\begin_layout Standard
The remove method, as the reader will have easily guessed, can be used to
 remove an icon from the FishEye, given its URL: 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true,language=Java"
inline false
status open

\begin_layout Plain Layout

fe.remove("amor.png");
\end_layout

\end_inset

It is possible to add and remove icons dynamically, that is while the FishEye
 is displayed.
\end_layout

\begin_layout Subsubsection
API of the FishEye
\end_layout

\begin_layout Standard
We saw how to add or remove icons from the menu.
 These two methods are the most important; however the FishEye class provides
 some other method which can be useful: get the added icons, the command
 associated…
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

countItems(): Counts the number of item in the FishEye menu.
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

indexOf(String): Returns the index position in the FishEye menu of an icon.
 
\end_layout

\begin_layout Description
Command
\begin_inset space ~
\end_inset

getCommand(String): Returns the Command of the icon from the URL of the
 associated icon.
 
\end_layout

\begin_layout Description
Command
\begin_inset space ~
\end_inset

getCommand(int): Returns the command at the index position in the FishEye
 menu.
\end_layout

\begin_layout Description
String[]
\begin_inset space ~
\end_inset

getIcons(): Returns all the icons from the FishEye menu.
 
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getIcon(int): Returns the URL of the icon at the index position.
\end_layout

\begin_layout Subsection
ColorChooser
\end_layout

\begin_layout Standard
The ColorChooser class provides to the user a palette of colors to choose
 from with the mouse.
 The ColoChooser component can be laid anywhere on the GWT module, it means
 that there are no constraints with the choice of a container of widgets.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/color_chooser_preview.png

\end_inset


\end_layout

\begin_layout Subsubsection
Create a ColorChooser.
\end_layout

\begin_layout Standard
The palette proposes a choice of 12 colors or 70 colors.
 There are two ways to create a palette of colors.  One without parameter,
 the easiest and an other with a parameter staying simple despite everything.
 First of all, we need to import the class like this: 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

import com.objetdirect.tatami.client.ColorChooser ; 
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Without parameter:
\end_layout

\begin_layout Standard
The palette of colors will have 70 colors by default.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

ColorChooser palette = new ColorChooser(); 
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
With parameter:
\end_layout

\begin_layout Standard
The parameter specifies the number of colors wanted for the palette.
 There are 2 static constant of the class ColorChooser.
 
\end_layout

\begin_layout Standard
The possible values are : 
\end_layout

\begin_layout Description
ColorChooser.SEVENTY_COLORS: For a palette with 70 colors.
\end_layout

\begin_layout Description
ColorChooser.TWELVE_COLORS: For a palette with 12 colors.
\end_layout

\begin_layout Standard
What gives us concretely: 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

ColorChooser 12Colors = new ColorChooser(ColorChooser.TWELVE_COLORS);
\end_layout

\begin_layout Plain Layout

ColorChooser 70Colors = new ColorChooser(ColorChooser.SEVENTY_COLORS);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Get,modify the selected color
\end_layout

\begin_layout Standard
.
 The ColorChooser class doesn’t handle really colors i.e.
 object modelling a color like java.awt.color by example.
 The ColorChooser class uses the hexadecimal representation format of a
 color.
 By default the selected value for each palette (12 or 70 colos) is: #000000
 which is the black color.
 
\end_layout

\begin_layout Paragraph
Modify the selected color:
\end_layout

\begin_layout Standard
The modification of the current color can be done by 2 ways.
 One by specifying the color that we want to select, or by a mouse click
 event on the palette, in this case it will have to be attached on the browser
 in order that events are taken into account.
 The signature of the method to modify the selected color is the following:
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ColorChooser#setColor(String) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The method takes in parameter a string.
 This string has to correspond to a color in its hexadecimal representation
 format as we said it before.
 Warning in this first version of this component there is not checking on
 the given string.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true,language=Java"
inline false
status open

\begin_layout Plain Layout

ColorChooser palette = new ColorChooser();
\end_layout

\begin_layout Plain Layout

palette.setColor("#c0c0c0"); /* silver color*/
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Get the selected color.
 
\end_layout

\begin_layout Standard
To get the selected color from the palette, use this simple method below:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true,language=Java"
inline false
status open

\begin_layout Plain Layout

String color = palette.getColor(); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The method getColor() returns the hexadecimal representation format of the
 color.
 
\end_layout

\begin_layout Subsubsection
Catch a change of the selected color.
 
\end_layout

\begin_layout Standard
The ColorChooser component has the property to notify a change of the selected
 color.
 To use this property, you just need to add a listener with a type com.google.gwt.u
ser.client.ui.ChangeListener.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true,language=Java"
inline false
status open

\begin_layout Plain Layout

ColorChooser palette = new ColorChooser(); label = new Label("no color selected"
);
\end_layout

\begin_layout Plain Layout

palette.addChangeListener(new ChangeListener() {  
\end_layout

\begin_layout Plain Layout

	public void onChange(Widget sender) { 	
\end_layout

\begin_layout Plain Layout

		String color = palette.getColor();
\end_layout

\begin_layout Plain Layout

		label.setText("The color selected : " + color); 
\end_layout

\begin_layout Plain Layout

		DOM.setStyleAttribute(label.getElement(), "color", color);  
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

});
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So, each time a new color will be selected, the text of the label will display
 the hexadecimal code of the color and, the text will have the color of
 the selected color.
\end_layout

\begin_layout Subsection
The Toaster component.
\end_layout

\begin_layout Standard
The Toaster class aims to display notifications to the users like the mailers
 application.
 These notifications are like tooltip appearing in one of the corners of
 a graphic container and disappearing with a fader effect (become more and
 more transparent) according to a timeout (1 second by example).
 The toaster can contain HTML code or simply a non formatted string.
 It’s necessary to note that the Toaster component is invisible for the
 user.
 It displays only the wished messages.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/toaster_preview.png

\end_inset


\end_layout

\begin_layout Subsubsection
Create a Toaster.
 
\end_layout

\begin_layout Standard
All object needs to be imported before to be instantiated:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import com.objetdirect.tatami.client.Toaster ; 
\end_layout

\end_inset

To create an instance of a Toaster we need to know principally 2 points.
 On the one hand is the topic for the component and on the other hand the
 position where the toaster appears on the graphical container.
 In fact, the second point, doesn’t concern only the position, but also
 the movement for the Toaster.
 An example: position in the right lower corner doing a movement from the
 bottom to the top.
 The possible positions are static constants of the Toaster class.
 
\end_layout

\begin_layout Description
Toaster.BOTTOM_RIGHT_UP: Position in the right lower corner, the message
 goes from the bottom to the top
\end_layout

\begin_layout Description
Toaster.BOTTOM_RIGHT_LEFT: Position in the right lower corner, the message
 goes from the right to the left.
\end_layout

\begin_layout Description
Toaster.BOTTOM_LEFT_UP: Position in the left lower corner, the message goes
 from the bottom to the top.
\end_layout

\begin_layout Description
Toaster.BOTTOM_LEFT_RIGHT: Position in the left lower corner, the message
 goes from the left to the right.
\end_layout

\begin_layout Description
Toaster.TOP_RIGHT_DOWN: Position in the right upper corner, the message goes
 from the top to the bottom.
\end_layout

\begin_layout Description
Toaster.TOP_RIGHT_LEFT: Position in the right upper corner, the message goes
 from the right to the left
\end_layout

\begin_layout Description
Toaster.TOP_LEFT_DOWN: Position in the left upper corner, the message goes
 from the bottom to the top.
\end_layout

\begin_layout Description
Toaster.TOP_LEFT_RIGHT: Position in the left upper corner, the message goes
 from the left to the right.
\end_layout

\begin_layout Standard
The topic of messages of the created Toaster is a string to define.
 Its usefulness will take a sense during the display of a message.
 There are 2 ways to create a Toaster.
 One of them is to specify the position and the topic: 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true,language=Java"
inline false
status open

\begin_layout Plain Layout

Toaster toaster = new Toaster("notification",Toaster.TOP_RIGHT_DOWN);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An other is to only specify the topic, the position will be then Toaster.BOTTOM_R
IGHT_UP
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true,language=Java"
inline false
status open

\begin_layout Plain Layout

Toaster toaster = new Toaster("notification");
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Display a notification.
 
\end_layout

\begin_layout Standard
Once an instance of a Toaster is created, we can throw some notifications.
 It’s at this level that the given topic during creation takes its sense.
 The Toaster component has 4 notifications available: error message, plain
 message, warning message and fatal message.
 
\end_layout

\begin_layout Standard
These types are represented by static constants of the Toaster class.
 
\end_layout

\begin_layout Description
Toaster.ERROR_MESSAGE: Use for error messages.
\end_layout

\begin_layout Description
Toaster.WARNING_MESSAGE: Use for warning messages.
\end_layout

\begin_layout Description
Toaster.FATAL_MESSAGE: Use for fatal messages.
\end_layout

\begin_layout Description
Toaster.PLAIN_MESSAGE: Use for standard messages.
\end_layout

\begin_layout Standard
The component has 4 methods for displaying the notifications.
 One of them is generic; the others use this generic method in order to
 simplify the passage of the parameters.
 The signature of the generic method is: 
\end_layout

\begin_layout Standard
public static void publish(String topic, String message, String type,int
 delay); 
\end_layout

\begin_layout Standard
As we can see, the method is static for the class Toaster, that’s why we
 need the parameter « topic » to get the instance of the Toaster to use
 for the positioning of the message.
 The parameter « message » will be the content displayed during the notification
; it can be a simple string or some HTML code as we had already noted it.
 The type of the notification can be specified with one of the 4 constants
 quoted previously.
 The notification being a panel that it disappears with a timeout, the parameter
 « delay » specifies the timeout.
 To avoid using the whole 4 parameters set, the Toaster class has 3 other
 methods defining the types of notification which will be displayed with
 a delay at 1 second.
 (See the constant Toaster.DELAY).
\end_layout

\begin_layout Description
publishMessage(String,String ): Display a standard message.
\end_layout

\begin_layout Description
publishWarning(String, String): Display a warning message.
\end_layout

\begin_layout Description
publishError(String,String): Display an error message.
\end_layout

\begin_layout Standard
The example below illustrates a use of the Toaster component.
 It is drawn from the GWT TatamiDemo module, module demonstrating the Tatami
 components.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

public class TatamiDemo implements EntryPoint {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public void onModuleLoad() {
\end_layout

\begin_layout Plain Layout

	RootPanel rootPanel = RootPanel.get();
\end_layout

\begin_layout Plain Layout

	FishEye = new FishEye();
\end_layout

\begin_layout Plain Layout

	Toaster toaster = new Toaster("message");
\end_layout

\begin_layout Plain Layout

	addItem("background.png", PADDLE, "paddle");
\end_layout

\begin_layout Plain Layout

	rootPanel.add(FishEye, 50, 50); rootPanel.add(toaster);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private void addItem(String icon, int page, String title) {
\end_layout

\begin_layout Plain Layout

	FishEye.add(icone, title, new DemoCommand(icon, page));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private class DemoCommand implements Command { 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public void execute() { Toaster.publishMessage("message",getMessage(icon));
 setPage(page); }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So, this code displays a notification each time that a user clicks on an
 item of the FishEye component.
 The notification will be displayed in the right lower corner and, will
 go from the bottom to the top with a delay of 1 second.
 
\end_layout

\begin_layout Standard
There is a second way to display a message in the toaster : it can be achieved
 by setting a message in the toaster and then manually show/hide it.
\end_layout

\begin_layout Standard
Below are the methods used to achieve this goal : 
\end_layout

\begin_layout Description
publishMessage(String,
\begin_inset space ~
\end_inset

String): Display a standard message.
\end_layout

\begin_layout Description
publishWarning(String,
\begin_inset space ~
\end_inset

String): Display a warning message.
\end_layout

\begin_layout Description
publishError(String,
\begin_inset space ~
\end_inset

String): Display an error message.
\end_layout

\begin_layout Subsection
The button component
\end_layout

\begin_layout Standard
While GWT provides a standard button , the Dojo button can be more interesting.
 In Dojo, we define a button appearance by its label and its icon-class.
 The label is the text which will be shown in the button, while the icon-class
 is the css class used to style the icon.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/button_preview.png

\end_inset


\end_layout

\begin_layout Standard
For example , the above button’s label is “Remove selected employees” while
 it’s icon-class is removeEmployeeButtonIcon, which is defined as following
 in a css file :
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true,language=HTML"
inline false
status open

\begin_layout Plain Layout

.removeEmployeeButtonIcon { background-image: url("list-remove.png"); height:
 32px; width: 32px; }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To import this widget see below: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import com.objetdirect.tatami.client.Button ; 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Create the Button component: 
\end_layout

\begin_layout Standard
The Button’s constructor has two parameters : the first one is it’s label
 , the second one is it’s icon-class.
 
\end_layout

\begin_layout Description
label: The label to be displayed on the button
\end_layout

\begin_layout Description
iconClass: The css class which should be applied to the icon.
\end_layout

\begin_layout Standard
Tatami’s button component is also extending GWT Button.
 That means you can also use a simple constructor with only the label, or
 another constructor with a default ClickListener.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Button button = new Button("Click on me","addEmployeeButton"); 
\end_layout

\begin_layout Plain Layout

RootPanel.get().add(button);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
API of the button component
\end_layout

\begin_layout Standard
Because it is extending the GWT Button Component, it has the same support
 for ClickListeners.
 To add a ClickListener to Tatami button component, just use addClickListener(Cl
ickListener listener).
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getText(): Gets the button’s label
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getIconClass(): Gets the button’s iconClass
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setText(String
\begin_inset space ~
\end_inset

label): Sets the button’s label
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

addClickListener(ClickListener
\begin_inset space ~
\end_inset

listener): Adds a listener for the onClick event
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

removeClickListener(ClickListener
\begin_inset space ~
\end_inset

listener): Removes a listener for the onClick event
\end_layout

\begin_layout Subsection
The NumberSpinner component
\end_layout

\begin_layout Description
A number spinner is a very convenient widget when it comes to manipulating
 numbers.
 Dojo Spinner is wrapped in Tatami by the NumberSpinner component.
 It provides the following features :
\end_layout

\begin_layout Itemize
Setting a max and min value for the spinner 
\end_layout

\begin_layout Itemize
Value can be changed using up/down key arrows or by up/down buttons
\end_layout

\begin_layout Itemize
Spinning accelerates when you hold down a button
\end_layout

\begin_layout Itemize
Displaying a tooltip when the value is out of range, when the value is invalid
 , or as a hint on what to put in the spinner
\end_layout

\begin_layout Standard
To import this widget see below: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import com.objetdirect.tatami.client.NumberSpinner;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Create the NumberSpinner component: 
\end_layout

\begin_layout Standard
There are several constructor’s for the number spinner.
 Let’s begin with the simplest one.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

NumberSpinner spinner = new NumberSpinner();
\end_layout

\end_inset

This creates a NumberSpinner with no constraints, with a default value of
 0, and a delta of 1.
 This delta is the spinner’s increment.
 
\end_layout

\begin_layout Standard
A second constructor is quite simple :
\end_layout

\begin_layout Description
initValue: Spinner’s default value
\end_layout

\begin_layout Description
minValue: Spinner’s min value.
 Any value under minValue will be considered invalid
\end_layout

\begin_layout Description
maxValue: Spinner’s max value.
 Any value above maxValue will be considered invalid
\end_layout

\begin_layout Description
delta: Spinner’s delta.
 It is the spinner’s increment when user hit a spinner button
\end_layout

\begin_layout Standard
The below snippet will create a spinner which value can range from 500 to
 1500 , with an increment of 100 and an init value equals to 1000.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

NumberSpinner spinner = new NumberSpinner(1000f, 500f, 1500f , 100f);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following constructor is the most complete one .
 Notice the constraints object, which is replaced by min and max value in
 another constructor for more convenience.
 The constraints object maps constraints to be applied to the spinner content.
 Please see the example below.
\end_layout

\begin_layout Description
defaultTimeout: Delay until the spinning accelerates
\end_layout

\begin_layout Description
invalidMessage :Message to be displayed in the tooltip when the value is
 not a number, or doesn’t satisfy any constraints.
\end_layout

\begin_layout Description
intermediateChanges: True : the spinner fires onChange event each time it
 is incremented False : the spinner only fires onChange event when the value
 is validated (that is, the spinner loses focus)
\end_layout

\begin_layout Description
delta: Spinner’s delta.
 It is the spinner’s increment when user hit a spinner button
\end_layout

\begin_layout Description
promptMessage: Helping tooltip to be displayed when the spinner doesn’t
 contain any value.
\end_layout

\begin_layout Description
rangeMessage: Tooltip to be displayed when the value is out of range (that
 is, above maxvalue or below minvalue)
\end_layout

\begin_layout Description
timeoutChangeRate: This coefficient represents the spinner acceleration.
 1.0 means that the spinner will not accelerate at all, values below 1.0 means
 that the spinner’s will accelerate (default to 0.9).
 The smaller the value is , the more acceleration the spinner will have.
 
\end_layout

\begin_layout Description
trim: Wether to trim (remove leading and trailing spaces) the number spinner’s
 content
\end_layout

\begin_layout Description
value: Spinner’s default value
\end_layout

\begin_layout Description
constraints: A map containing the spinner’s constraints
\end_layout

\begin_layout Standard
Below , the code that produces the above spinner : 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Map constraints = new HashMap();
\end_layout

\begin_layout Plain Layout

constraints.put("min", new Float(500f));
\end_layout

\begin_layout Plain Layout

constraints.put("max", new Float(1500f));
\end_layout

\begin_layout Plain Layout

/** The following key/value couple indicates the number *format pattern
 , according to unicode number format 
\end_layout

\begin_layout Plain Layout

 * pattern.
 
\end_layout

\begin_layout Plain Layout

 * The following pattern also means that any value with 
\end_layout

\begin_layout Plain Layout

 * more than two decimals will be considered invalid 
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

constraints.put("pattern" , "#,##0");
\end_layout

\begin_layout Plain Layout

NumberSpinner spinner = new NumberSpinner(100, "Please enter a valid number
 without any decimal places", false , 100f ,"Please enter a value between
 500 and 1500" , "Value is out of range" , 0.90f , true, 1000, constraints);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Constraints 
\end_layout

\begin_layout Standard
The number spinner component can be constrained with some parameters.
 Those are:
\end_layout

\begin_layout Description
NumberSpinner.CONSTRAINT_MIN: Sets a minimum value for the spinner.
\end_layout

\begin_layout Description
NumberSpinner.CONSTRAINT_MAX: Sets a maximum Value for the spinner.
\end_layout

\begin_layout Description
NumberSpinner.CONSTRAINT_PATTERN : Sets the number pattern.
 See http://www.unicode.org/reports/tr35/#Number_Format_Patterns.
 For example, with a pattern equal to “#,##0.##”, the input numbers will
 be constrained to 2 decimal places.
\end_layout

\begin_layout Description
NumberSpinner.CONSTRAINT_TYPE: Sets the value type for the number.
 It can be either “percent” , “decimal” or “currency”.
 We advise not to set this constraint after the spinner has been created.
\end_layout

\begin_layout Description
NumberSpinner.CONSTRAINT_CURRENCY: Sets the currency symbol for the spinner.
 It has no effects if the type constraints is not set to “currency”.
\end_layout

\begin_layout Standard
To set one of these constraints , just use the following method :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void addConstraint(String, String) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example, if you want to set the max value for your spinner to 50 , just
 use the following snippet :
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

mySpinner.addConstraint(NumberSpinner.CONSTRAINT_MAX , "50");
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
API of the number spinner component
\end_layout

\begin_layout Standard
The number spinner supports ChangeListeners.
 To add a ChangeListener to Tatami NumberSpinner component, just use addChangeLi
stener(ChangeListener listener).
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getValue(): Gets  the spinner’s value
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

setValue(): Sets the spinner’s value
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

addConstraint(String,String): Adds a constraint to the spinner.
 
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

removeConstraint(String): Removes a constraint from the spinner.
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setConstraints(Map
\begin_inset space ~
\end_inset

constraint): Sets the spinner constraints to the given map, filled with
 constraint names as keys and their parameter as values.
\end_layout

\begin_layout Description
Map
\begin_inset space ~
\end_inset

getConstraints(): Gets the spinner constraints map
\end_layout

\begin_layout Description
setDelta(float): Sets the spinner increment
\end_layout

\begin_layout Description
float
\begin_inset space ~
\end_inset

getDelta(): Gets the spinner increment
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setIntermediateChanges(boolean): Sets wether an “onChange” event should
 be fired each time the number spinner is incremented (ie, an arrow is clicked)
 or only when it loses focus.
\end_layout

\begin_layout Description
isIntermediateChanges(): Gets wether an “onChange” event is fired each time
 the number spinner is incremented.
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

addChangeListener(ChangeListener
\begin_inset space ~
\end_inset

listener): Adds a listener for the onChange event
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

removeClickListener(ChangeListener
\begin_inset space ~
\end_inset

listener): Removes a listener for the onChange event
\end_layout

\begin_layout Subsection
The clock component.
\end_layout

\begin_layout Standard
It can be useful to show a clock in a module, on one hand for informal reasons
 (know the hour), and on the other hand for the aesthetic aspect of module.
 The component Clock shows the common hour in a graphic container.
 The shown clock is a clock with needles.
\end_layout

\begin_layout Standard
The clock since Tatami 1.1 has some new features through its GFX package.
 Indeed the clock is not supported in Dojo 1.0 release, but the Dojo Team
 decided to create a new Clock component using its GFX package.
 So the Clock component doesn’t wrap a Dojo widget directly and so doesn’t
 implement the HasDojo interface.
 Now, you can change the background image, the size, colors of the needles…
 To import this widget see below: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import com.objetdirect.tatami.client.Clock ; 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Create the Clock component: 
\end_layout

\begin_layout Standard
The constructor of clock has two parameters: 
\end_layout

\begin_layout Description
url: An URL of an image to use for the background.
 If null is given then no image will be set
\end_layout

\begin_layout Description
width: The width for the background image, and so the width for the clock
 itself.
\end_layout

\begin_layout Standard
A constructor with no parameter is also available.
 It means that the clock will be an URL set to null and a width of 192 pixels.
 
\end_layout

\begin_layout Standard
Below a concrete example: 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

Clock clock = new Clock("clock_face.jpg",385); 
\end_layout

\begin_layout Plain Layout

RootPanel.get().add(clock, 490, 150);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
API of the clock component 
\end_layout

\begin_layout Standard
Below, these are the methods to custom the clock component.
 
\end_layout

\begin_layout Description
Date
\begin_inset space ~
\end_inset

getTime(): Returns the current time of the Clock
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getImage(): Returns background image of the clock or null, if no image used.
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

getWidth(): Returns the width of the clock 
\end_layout

\begin_layout Standard
The following methods set or get the fill color, stroke color or the width
 of the stroke of a respective needle.
 (hours, seconds and minutes) :
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setHourColor(Color) 
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setHourStrokeColor(Color)
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setHourStrokeWidth(int)
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setMinuteColor(Color)
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setMinuteStrokeColor(Color)
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setMinuteStrokeWidth(int)
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setSecondColor(Color)
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setSecondStrokeColor(Color)
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setSecondStrokeWidth(int)
\end_layout

\begin_layout Description
Color
\begin_inset space ~
\end_inset

getHourColor()
\end_layout

\begin_layout Description
Color
\begin_inset space ~
\end_inset

getHourStrokeColor()
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

getHourStrokeWidth()
\end_layout

\begin_layout Description
Color
\begin_inset space ~
\end_inset

getMinuteColor()
\end_layout

\begin_layout Description
Color
\begin_inset space ~
\end_inset

getMinuteStrokeColor()
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

getMinuteStrokeWidth()
\end_layout

\begin_layout Description
Color
\begin_inset space ~
\end_inset

getSecondColor()
\end_layout

\begin_layout Description
Color
\begin_inset space ~
\end_inset

getSecondStrokeColor()
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

getSecondStrokeWidth()
\end_layout

\begin_layout Subsection
The BasePicker, TimePicker and DatePicker components.
\end_layout

\begin_layout Standard
Tatami offers components allowing the selection of dates or time easily.
 The DatePicker allows the selection of date within a calendar, whereas
 the time picker allows the selection of time within a time table.
 These two components are implementations of the abstract class BasePicker
 which introduces a common API for components allowing date or time selection.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/timeAndDatePicker_preview.png

\end_inset


\end_layout

\begin_layout Standard
As for all components in Tatami, it is the addition in the navigator who
 allows showing components.
 
\end_layout

\begin_layout Subsubsection
Create a TimePicker
\end_layout

\begin_layout Standard
To create a TimePicker component, you need to specify 3 parameters.
 These parameters permit to refine the available times that users can select
 and also the format of the time.
 By default no time is chosen.
 
\end_layout

\begin_layout Standard
To import the component do this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import com.objetdirect.tatami.client.TimePicker;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Below you see the details of the parameters which can be passed to the construct
or.
 
\end_layout

\begin_layout Description
startDate: The “minimum” date that a user can select.
 
\end_layout

\begin_layout Description
endDate: The “maximum” date that a user can select.
\end_layout

\begin_layout Description
constraints: A TimerPickerConstraint to specify the selectable time and
 the format of the time to select.
\end_layout

\begin_layout Standard
There are also two others constructor, to simplify the use of the TimePicker
 component.
\end_layout

\begin_layout Standard
A constructor with no parameter, there are no time restriction and the style
 of the TimePicker is like that: 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/timePicker_firstExample.png

\end_inset


\end_layout

\begin_layout Standard
You see 5 hours and these hours are split every 15 minutes.
 In the second constructor you just specify the constraints.
 
\end_layout

\begin_layout Standard
The TimerPickerConstraint is a class with four public attributes to determine
 the constraints: 
\end_layout

\begin_layout Description
visibleRange: ISO-8601 string representing the range of this TimePicker
 The TimePicker will only display times in this range Example: "T05:00:00"
 displays 5 hours of options default is "T05:00:00" :
\end_layout

\begin_layout Description
clickableIncrement: ISO-8601 string representing the amount by which every
 clickable element in the time picker increases Set in non-Zulu time, without
 a time zone Example: "T00:15:00" creates 15 minute increments.
 Must divide visibleIncrement evenly default is "T00:15:00".
\end_layout

\begin_layout Description
visibleIncrement: ISO-8601 string representing the amount by which every
 element with a visible time in the time picker increases.
 Set in non Zulu time, without a time zone Example: "T01:00:00" creates
 text in every 1 hour increment default is "T01:00:00",
\end_layout

\begin_layout Description
timePattern: TimePattern see the DOJO explanations : it's like in JAVA for
 the most of principals options default is "HH:mm"
\end_layout

\begin_layout Standard
The instantiation of a TimePicker is made as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

TimePickerConstraints constraints= new TimePickerConstraints();
\end_layout

\begin_layout Plain Layout

constraints.clickableIncrement = TimePickerConstraints.EVERY_HALF_HOUR;
\end_layout

\begin_layout Plain Layout

timePicker = new TimePicker(constraints);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see in the code some constants are defined to simplify the use
 of the TimePickerConstraint class.
\end_layout

\begin_layout Subsubsection
Create a DatePicker
\end_layout

\begin_layout Standard
The component DatePicker allows the selection of date, the date to choose
 can be bounded by a lower and an upper limit like the TimePicker.
 It’s possible to not specify these limits; in that case all possible dates
 will be effluent.
 The importation of the class this fact in the following way:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import com.objetdirect.tatami.client.DatePicker;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To select a Date without constraints, do this: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

DatePicker datePicker = new DatePicker(); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To select a Date with constraints do this : 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

//start2007 correspond to the date : 01/01/2007 
\end_layout

\begin_layout Plain Layout

//end2008 correspond to 12/31/2008 
\end_layout

\begin_layout Plain Layout

DatePicker picker = new DatePicker(start2007, end2008);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The API of DatePicker and TimePicker: 
\end_layout

\begin_layout Standard
The API to manipulate a BasePicker consists in choosing a date in most cases
 and recovering this date chosen.
 The user can choose a date of course by mouse events on the component.
 
\end_layout

\begin_layout Standard
To set the default selected date and get the date selected by a user:
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setDate(Date): sets the default selected date
\end_layout

\begin_layout Description
Date
\begin_inset space ~
\end_inset

getDate(): get the currently selected date
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setTime(Date): sets the default selected time for a TimePicker
\end_layout

\begin_layout Description
Date
\begin_inset space ~
\end_inset

getTime(): gets the default selected time for a TimePicker
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

getMinDate(): Returns the minimum available date in the calendar or in the
 time picker
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

getMaxDate(): Returns the maximum available date in the calendar or in the
 time picker
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

addChangeListener(ChangeListener): Adds a ChangeListener when the seletected
 date value changes.
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

removeChangeListener(ChangeListener): Removes a ChangeListener when the
 seletected date value changes.
\end_layout

\begin_layout Standard
We can listen to selection changes, by adding a listener of type com.google.gwt.use
r.client.ui.ChangeListener to the component.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

TimePicker timer = new TimePicker();
\end_layout

\begin_layout Plain Layout

timer.addChangeListener(new ChangeListener() {
\end_layout

\begin_layout Plain Layout

	public void onChange(Widget sender) {
\end_layout

\begin_layout Plain Layout

		Window.alert("New time :" + timer.getTime() );
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

});
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each times a new time will be selected; an alert will be displayed showing
 the new selection.
 
\end_layout

\begin_layout Subsection
The DropdownContainer, DropdownDatePicker et DropdownTimePicker components.
 
\end_layout

\begin_layout Standard
Tatami offers components which allow the simplification of an entered of
 temporal information as date or a time.
 Both components which allow this are DropdownDatePicker (at the left) for
 a date input and DropdownTimePicker (at the right) for a time input.
 These two classes implement the abstract class DropdownContainer allowing
 the input of temporal information.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/dropdownTimeAndDatePickers.png

\end_inset


\end_layout

\begin_layout Standard
The inputs are simplified due to the fact that the user will be able to
 select their temporal information using a BasePicker component (ie, TimePicker
 or DatePicker).
 Once its information was chosen, the field text of seizure will have the
 value of this information and will be formatted.
 
\end_layout

\begin_layout Standard
Moreover, these components perform a validation on the entered text and
 indicate in a tooltip the expected format (for example: hh:mm for time
 information).
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/dropdownDatePicker_validation.png

\end_inset


\end_layout

\begin_layout Standard
If the format is incorrect the user is warned by another tooltip and the
 color of the text field changes:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/dropdownDatePicker_validationFailed.png

\end_inset


\end_layout

\begin_layout Subsubsection
Create a DropdownDatePicker.
\end_layout

\begin_layout Standard
The component DropdownDatePicker allows to grab a date in a text field via
 a DatePicker component.
 So, the selected date will be formatted accordingly to the user's locale.
 Example: 08/28/2007 for a locale EN.
\end_layout

\begin_layout Standard
To import the class: 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

import com.objetdirect.tatami.client.DropdownDatePicker;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are 2 constructors for a DropDwonDatePicker, one with two parameters
 and one with no parameters.
 The parameters will have default values.
 
\end_layout

\begin_layout Description
startDate: the lowest allowed value 
\end_layout

\begin_layout Description
endDate: the highest allowed value
\end_layout

\begin_layout Standard
An example: 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

DropdownDatePicker dddp = new DropdownDatePicker();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Or 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

DropdownDatePicker dddp = new DropdownDatePicker(startDate, endDate);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This creates our component, which has to be attached to the browser.
\end_layout

\begin_layout Subsubsection
Create a DropdownTimePicker.
\end_layout

\begin_layout Standard
The DropdownTimePicker component permits to enter a time with hours and
 minutes in an text fied via the TimePicker component.
 So, the selected date will be formatted accordingly to a defined time pattern.
 Example: 2:30 
\end_layout

\begin_layout Standard
To import the class: 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

import com.objetdirect.tatami.client.DropdownTimePicker;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are 3 constructors available.
 The most “complex” constructor needs 3 parameters.
 The others set some default values on these 3 parameters.
 
\end_layout

\begin_layout Description
startDate: the lowest allowed value 
\end_layout

\begin_layout Description
endDate: the highest allowed value
\end_layout

\begin_layout Description
timePattern: To format the time information.
 See the DOJO explanations for more details about the time pattern.
 It's like in JAVA for the most of principals options.
 Default is "HH:mm"
\end_layout

\begin_layout Standard
An example: 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

DropdownTimePicker ddtp = new DropdownTimePicker(); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Or
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

DropdownTimePicker ddtp = new DropdownTimePicker("HH:mm"); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Or 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

DropdownTimePicker ddtp = new DropdownTimePicker(startDate, endDate,"HH:mm");
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This creates our component, which has to be attached to the browser.
\end_layout

\begin_layout Subsubsection
The API of the DropdownTimePicker and DropdownDatePicker.
\end_layout

\begin_layout Standard
The API of these components comes from the DropdownContainer class.
 
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setDate(Date): sets the default selected date
\end_layout

\begin_layout Description
Date
\begin_inset space ~
\end_inset

getDate(): get the currently selected date
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setTime(Date): sets the default selected time for a TimePicker
\end_layout

\begin_layout Description
Date
\begin_inset space ~
\end_inset

getTime(): gets the default selected time for a TimePicker
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

getMinDate(): Returns the minimum available date in the calendar or in the
 time picker
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

getMaxDate(): Returns the maximum available date in the calendar or in the
 time picker
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

addChangeListener(ChangeListener): Adds a ChangeListener when the seletected
 date value changes.
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

removeChangeListener(ChangeListener): Removes a ChangeListener when the
 seletected date value changes.
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setText(String): Writes some text in the text field of the DropdownContainer.
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getText(): Returns the time information as a string.
 
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setEnabled(boolean): Enables or disables the DropdownContainer.
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setInvalidMessage(String): Sets the message displayed when the user's input
 is not valid.
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getInvalidMessage(): Gets the message displayed when the user's input is
 not valid.
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setPromptMessage(String): Sets the message helping the user to respect the
 expected format.
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getPromptMessage(): Gets the message helping the user to respect the expected
 format.
\end_layout

\begin_layout Description
Boolean
\begin_inset space ~
\end_inset

isValid(): Indicates if the entered text is valid or not.
 
\end_layout

\begin_layout Standard
Below, you will find an example extracted from the project TatamiDemo-1.1
 which presents the DropdownTimePicker, DropdownDatePicker, TimePicker and
 DatePicker components.
 These different components notify their change of values and update some
 others components treating the same type of data.
 It’s means that the DatePicker will be linked with the DropdownDatePicker
 and the TimePicker will be linked with the DropdownTimePicker.
 So if the TimePicker is modified then it will update the DropdownTimePicker
 if it’s necessary, same for the DatePicker with the DropdownDatePicker.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

private void initComponents() {
\end_layout

\begin_layout Plain Layout

	mainPanel = new HorizontalPanel();
\end_layout

\begin_layout Plain Layout

	mainPanel.setSpacing(50);
\end_layout

\begin_layout Plain Layout

	VerticalPanel timePanel = new VerticalPanel();
\end_layout

\begin_layout Plain Layout

	VerticalPanel datePanel = new VerticalPanel();
\end_layout

\begin_layout Plain Layout

	datePanel.setSpacing(20);
\end_layout

\begin_layout Plain Layout

	timePanel.setSpacing(20);
\end_layout

\begin_layout Plain Layout

	inputDate = new DropdownDatePicker();
\end_layout

\begin_layout Plain Layout

	inputDate.setInvalidMessage("the date is incorrect");
\end_layout

\begin_layout Plain Layout

	datePicker = new DatePicker();
\end_layout

\begin_layout Plain Layout

	datePicker.setDate(new Date());
\end_layout

\begin_layout Plain Layout

	datePanel.add(htmlInputDate);
\end_layout

\begin_layout Plain Layout

	datePanel.add(inputDate);
\end_layout

\begin_layout Plain Layout

	datePanel.add(htmlDatePicker);
\end_layout

\begin_layout Plain Layout

	datePanel.add(datePicker);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	linkDropdownAndPicker(inputDate, datePicker);
\end_layout

\begin_layout Plain Layout

	inputTime = new DropdownTimePicker();
\end_layout

\begin_layout Plain Layout

	inputTime.setPromptMessage("HH:mm");
\end_layout

\begin_layout Plain Layout

	TimePickerConstraints constraints= new TimePickerConstraints();
\end_layout

\begin_layout Plain Layout

	constraints.clickableIncrement = TimePickerConstraints.EVERY_HALF_HOUR;
\end_layout

\begin_layout Plain Layout

	timePicker = new TimePicker(constraints);
\end_layout

\begin_layout Plain Layout

	timePanel.add(htmlInputTime);
\end_layout

\begin_layout Plain Layout

	timePanel.add(inputTime);
\end_layout

\begin_layout Plain Layout

	timePanel.add(htmlTimePicker);
\end_layout

\begin_layout Plain Layout

	timePanel.add(timePicker);
\end_layout

\begin_layout Plain Layout

	linkDropdownAndPicker(inputTime, timePicker);
\end_layout

\begin_layout Plain Layout

	mainPanel.add(datePanel);
\end_layout

\begin_layout Plain Layout

	mainPanel.add(timePanel);
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

private void linkDropdownAndPicker(final DropdownContainer container,final
 BasePicker picker) {
\end_layout

\begin_layout Plain Layout

	container.addChangeListener(new ChangeListener() {
\end_layout

\begin_layout Plain Layout

		public void onChange(Widget sender) {
\end_layout

\begin_layout Plain Layout

			if (!equalsObj(picker.getDate(), container.getDate())) {
\end_layout

\begin_layout Plain Layout

				picker.setDate(container.getDate()); 
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	});
\end_layout

\begin_layout Plain Layout

	picker.addChangeListener(new ChangeListener() {
\end_layout

\begin_layout Plain Layout

		public void onChange(Widget sender) {
\end_layout

\begin_layout Plain Layout

			if (!equalsObj(container.getDate(), picker.getDate())) {
\end_layout

\begin_layout Plain Layout

				container.setDate(picker.getDate());
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	});
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Slider component
\end_layout

\begin_layout Standard
The Slider component permits to modify the position of a cursor.
 At this position, is associated a value.
 The value is bounded by a maximum and a minimum value.
 The slider has two positions: vertical and horizontal.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/slidersPreview.png

\end_inset


\end_layout

\begin_layout Subsubsection
Create a Slider.
 
\end_layout

\begin_layout Standard
To import the Slider class:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import com.objetdirect.tatami.client.Slider;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To create a Slider, we need 5 parameters: 
\end_layout

\begin_layout Standard
position: Slider.HORIZONTAL or Slider.VERTICAL determines the position for
 the slider.
 
\end_layout

\begin_layout Description
minimum: Sets the minimum value available on the slider
\end_layout

\begin_layout Description
maximum: Sets the maximum value available on the slider
\end_layout

\begin_layout Description
initialValue: determines the initial cursor's position.
\end_layout

\begin_layout Description
showButtons: Boolean permitting to show or hide the button to increment
 or decrement the position of the cursor.
\end_layout

\begin_layout Standard
Example of using the Slider constructor :
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

// 0 is the min value.
\end_layout

\begin_layout Plain Layout

// 100 is the max value.
\end_layout

\begin_layout Plain Layout

// 50 is the initial value.
\end_layout

\begin_layout Plain Layout

//no buttons are shown
\end_layout

\begin_layout Plain Layout

Slider slider = new Slider(Slider.HORIZONTAL, 0,100,50,false); 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The API of the Slider component.
 
\end_layout

\begin_layout Standard
Principal methods from the Slider component :
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setValue(int): Modifies the selected value on the cursor
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

getValue(): Returns the current selected value.
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

getMaximunValue(): Returns the maximum allowed value.
 
\end_layout

\begin_layout Description
int getMinimumValue(): Returns the minimum allowed value.
 
\end_layout

\begin_layout Description
void setEnabled(boolean): enables or disables the slider
\end_layout

\begin_layout Description
Boolean isEnabled() : returns whether the slider is enabled or not
\end_layout

\begin_layout Standard
The following methods are used to add or remove rule marks at different
 positions on the slider.
 The first parameter sets the number of ticks, and the second one their
 size in any standard css unit (
\begin_inset Quotes eld
\end_inset

px
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

em
\begin_inset Quotes erd
\end_inset

 etc...).
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setRuleMarkBottom(int,String)
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setRuleMarkTop(int,String)
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setRuleMarkLeft(int,String)
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setRuleMarkRight(int,String)
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

removeRuleMarkBottom()
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

removeRuleMarkTop()
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

removeRuleMarkLeft()
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

removeRuleMarkRight()
\end_layout

\begin_layout Standard
The following methods are used to add or remove labels on each rule mark
 set.
 The first argument is an array containing the labels, the second one is
 the css style applied to this label.
 
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setRuleLabelsTop(String[],String)
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setRuleLabelsBottom(String[],String)
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setRuleLabelsLeft(String[],String)
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

setRuleLabelsRight(String[],String)
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

removeLabelsTop()
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

removeLabelsBottom()
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

removeLabelsLeft()
\end_layout

\begin_layout Description
void
\begin_inset space ~
\end_inset

removeLabelsRight()
\end_layout

\begin_layout Standard
The following methods return the labels on a specific position.
 If there are no labels, they return null.
\end_layout

\begin_layout Description
String[]
\begin_inset space ~
\end_inset

getLabelsLeft()
\end_layout

\begin_layout Description
String[]
\begin_inset space ~
\end_inset

getLabelsRight()
\end_layout

\begin_layout Description
String[]
\begin_inset space ~
\end_inset

getLabelsBottom()
\end_layout

\begin_layout Description
String[]
\begin_inset space ~
\end_inset

getLabelsTop()
\end_layout

\begin_layout Standard
The following methods return the labels style for a specific position: 
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getLabelsTopStyle()
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getLabelsBottomStyle()
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getLabelsRightStyle()
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getLabelsLeftStyle()
\end_layout

\begin_layout Standard
The following methods return the number of mark at the specified position:
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

countRuleMarkTop()
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

countRuleMarkBottom()
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

countRuleMarkLeft()
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

countRuleMarkRight()
\end_layout

\begin_layout Standard
The following methods return the mark size at the specified position
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getSizeRuleMarkTop()
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getSizeRuleMarkBottom()
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getSizeRuleMarkLeft()
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getSizeRuleMarkRight()
\end_layout

\begin_layout Subsubsection
Add some rule mark ands and labels.
\end_layout

\begin_layout Standard
Below stands an example of how to add some rule mark and labels on a Slider
 component.
 See also the project TatamiDemo-1.1.
 You can add a rule mark at the right, left, top, bottom of the slider,
 it depends of the position (vertical or horizontal) of the slider.
 But if you add a rule mark at the right position while the slider has a
 horizontal value, the rule mark will be displayed at the bottom of the
 slider.
 To set a rule mark, you need to know how many marks you want and their
 size.
 For the labels it’s the same thing, but instead of giving a number you
 give an array of String corresponding to each label.
 Moreover you can specify the labels css style.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

Slider verticalSlider = new Slider(Slider.VERTICAL, 0, 100, 100,true);
\end_layout

\begin_layout Plain Layout

verticalSlider.setRuleMarkLeft(6, "5px");
\end_layout

\begin_layout Plain Layout

verticalSlider.setRuleMarkRight(12, "3px");
\end_layout

\begin_layout Plain Layout

String[] labels = {" ","20%","40%","60%","80%", " "};
\end_layout

\begin_layout Plain Layout

verticalSlider.setLabelsLeft(labels,"margin: 0px -0.5em 0px -2em;color:gray");
\end_layout

\begin_layout Plain Layout

Slider horizontalSlider = new Slider
\end_layout

\begin_layout Plain Layout

(Slider.HORIZONTAL, 0, 100, 100,true);
\end_layout

\begin_layout Plain Layout

horizontalSlider.setRuleMarkBottom(6, "5px"); horizontalSlider.setLabelsTop(labels
,"margin: -0.5em 0px -3.5em 0px;color:gray");
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
RuleMark and RuleLabels components
\end_layout

\begin_layout Standard
RuleMark and RuleLabels permit to create some mark or some labels in a vertical
 or horizontal position.
 The distance between each marks or labels is based on the size of the component
 (RuleMark or RuleLabels).
 These components are used in the Slider component; see the documentation
 of this component to understand how RuleMark and RuleLabels are created.
 Below, this is an example of RuleMark and RuleLabels components to create
 a rule for a graphic canvas or an editor for example.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/ruleMarks_preview.png

\end_inset


\end_layout

\begin_layout Subsubsection
Create a RuleMark component.
 
\end_layout

\begin_layout Standard
To import the RuleMark class, just do this: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import com.objetdirect.tatami.client.RuleMark;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To create a RuleMark component you need specify 4 parameters.
 One parameter is optional; the others are required and cannot be have a
 default value.
 
\end_layout

\begin_layout Description
type: Determines if the RuleMark will be set in horizontal or vertical position
\end_layout

\begin_layout Description
count: The number of marks to display
\end_layout

\begin_layout Description
size: The size for each mark in pixel, em…
\end_layout

\begin_layout Description
position: The position to use for the RuleMark in the parent container,
 this parameter is optional.
 But it is used in the Slider to specify the position of the RuleMark on
 the Slider left, top, bottom, right.
 In fact if this RuleMark is a child of a dojo widget, this RuleMark will
 be connected to its parent node by the position.
 The default position is “containerNode”.
 
\end_layout

\begin_layout Subsubsection
The API of the RuleMak component
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getSize(): Returns the size of each mark.
 The size is in pixel, em….
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

getCount(): Returns the number or marks in the RuleMark.
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getPosition(): Returns the position of the RuleMark, default is containerNode
 
\end_layout

\begin_layout Subsubsection
Create a RuleLabels Component.
\end_layout

\begin_layout Standard
A RuleLabels component extends the RuleMark component, but instead of writing
 some marks, some labels are displayed.
 To import the class do this: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import com.objetdirect.tatami.client.RuleLabels;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Like the RuleMark, the RuleLabels needs 4 parameters but instead of specifying
 the number of marks, we specify an array of labels where labels are just
 string characters.
 So the number of labels is calculated by the length of the array.
 Also, we specify the style for the labels and not the size.
 The style is exactly the same than a CSS style.
 (color, font-family,margin…)
\end_layout

\begin_layout Description
type: Determines if the RuleMark will be set in horizontal or vertical position
\end_layout

\begin_layout Description
labels: An array of string corresponding to the labels.
\end_layout

\begin_layout Description
style: The style for the labels (color, font, margin etc…) Use the CSS syntax.
\end_layout

\begin_layout Description
position: The same that the RuleMark class.
 
\end_layout

\begin_layout Subsubsection
The API of the RuleLabels component
\end_layout

\begin_layout Description
String[]
\begin_inset space ~
\end_inset

getLabels(): Returns all the labels to display.
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getStyle(): Returns the style used for each label.
\end_layout

\begin_layout Description
int
\begin_inset space ~
\end_inset

getCount(): Returns the number or labels.
\end_layout

\begin_layout Description
String
\begin_inset space ~
\end_inset

getPosition(): Returns the position of the RuleLabels, default is containerNode
\end_layout

\begin_layout Subsubsection
An example
\end_layout

\begin_layout Standard
Below stands an example, which demonstrates how to create the rule presented
 in the screenshot at the beginning of this chapter.
 Note that in the project TatamiDemo there are no example.
 The use of RuleMark and RuleLabels is hidden by the Slider component in
 the SliderDemo class.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

RuleMark rule = new RuleMark(RuleMark.HORIZONTAL,15,"7px");
\end_layout

\begin_layout Plain Layout

DOM.setStyleAttribute(rule.getElement(),"borderTop","solid 1px");
\end_layout

\begin_layout Plain Layout

RuleMark rule2 = new RuleMark(RuleMark.HORIZONTAL,3,"15px");
\end_layout

\begin_layout Plain Layout

rule.setWidth("300px");
\end_layout

\begin_layout Plain Layout

rule.setHeight("20px");
\end_layout

\begin_layout Plain Layout

rule2.setWidth("300px");
\end_layout

\begin_layout Plain Layout

RootPanel.get().add(rule,20,100);
\end_layout

\begin_layout Plain Layout

RootPanel.get().add(rule2,rule.getAbsoluteLeft(), rule.getAbsoluteTop());
\end_layout

\begin_layout Plain Layout

String[] labelsArray = {"0","5","10","15"};
\end_layout

\begin_layout Plain Layout

RuleLabels labels = new RuleLabels(RuleLabels.HORIZONTAL, labelsArray, "margin:-0.
5em -0.5px 5px -.2.5em;color:gray");
\end_layout

\begin_layout Plain Layout

labels.setWidth("300px");
\end_layout

\begin_layout Plain Layout

RootPanel.get().add(labels,rule.getAbsoluteLeft(), rule.getAbsoluteTop()-10);
\end_layout

\begin_layout Plain Layout

RuleMark rule4 = new RuleMark(RuleMark.VERTICAL,15,"7px");
\end_layout

\begin_layout Plain Layout

RuleMark rule5 = new RuleMark(RuleMark.VERTICAL,3,"15px");
\end_layout

\begin_layout Plain Layout

rule4.setHeight("300px");
\end_layout

\begin_layout Plain Layout

rule5.setHeight("300px");
\end_layout

\begin_layout Plain Layout

RootPanel.get().add(rule4,rule.getAbsoluteLeft(), rule.getAbsoluteTop());
\end_layout

\begin_layout Plain Layout

DOM.setStyleAttribute(rule4.getElement(),"borderLeft","solid 1px");
\end_layout

\begin_layout Plain Layout

RootPanel.get().add(rule5,rule.getAbsoluteLeft(), rule.getAbsoluteTop());
\end_layout

\begin_layout Plain Layout

RuleLabels labels2 = new RuleLabels(RuleLabels.VERTICAL, labelsArray2, "margin:
 -0.5em -0.5px 5px -.2.5em;color:gray");
\end_layout

\begin_layout Plain Layout

labels2.setHeight("300px");
\end_layout

\begin_layout Plain Layout

RootPanel.get().add(labels2,rule.getAbsoluteLeft()-15, rule.getAbsoluteTop());
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Advanced Widgets
\end_layout

\begin_layout Subsection
The Grid component
\end_layout

\begin_layout Standard
Introduced in Tatami version 1.2 , the grid component provides a rich table,
 with nice features such as client-side sorting, lazy loading , view change
 , paging , in-cell editing, data formatting … 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/grid_preview.png

\end_inset


\end_layout

\begin_layout Subsubsection
Building and manipulating a simple grid : an example
\end_layout

\begin_layout Standard
This section will introduce the basics about building and manipulating a
 grid.
 We will learn how to create a grid, how to add/remove rows or columns and
 the basic grid settings.
 For further information, refer to Grid API and Grid MVC sections
\end_layout

\begin_layout Paragraph
Building a simple Grid
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Grid grid = new Grid(); 
\end_layout

\begin_layout Plain Layout

grid.addColumn("Name");
\end_layout

\begin_layout Plain Layout

grid.addColumn("Phone Number");
\end_layout

\begin_layout Plain Layout

grid.addColumn("BirthDate"); 
\end_layout

\begin_layout Plain Layout

Object[] row1 = {"John Doe" , "0123456789" , new Date("03/25/1981") };
\end_layout

\begin_layout Plain Layout

Object[] row2 = {"Jane Doe" , "9876543210" , new Date("11/12/1978")};
\end_layout

\begin_layout Plain Layout

grid.addRow(row1);
\end_layout

\begin_layout Plain Layout

grid.addRow(row2);
\end_layout

\begin_layout Plain Layout

grid.setWidth("300px");
\end_layout

\begin_layout Plain Layout

grid.setHeight("200px");
\end_layout

\begin_layout Plain Layout

RootPanel.get().add(grid);
\end_layout

\begin_layout Plain Layout

grid.updateGrid();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The above snippet will produce the following grid :
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/grid_simpleexample.png

\end_inset


\end_layout

\begin_layout Standard
Notice that the date is displayed using the standard ISO notation.
 Please refer to Cell editing and formatting section know how to display
 it properly.
\end_layout

\begin_layout Standard
It’s default properties make it user sortable, and we can add and remove
 rows and columns as we wish.
 
\end_layout

\begin_layout Paragraph
Settings
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
After creating the grid , and before attaching it to the dom tree, we can
 set a bunch of properties.
 
\end_layout

\begin_layout Description
setAutoHeight(boolean): true indicates that the grid should auto adapt its
 height, false that its height is fixed.
 Default : false
\end_layout

\begin_layout Description
setAutoWidth(boolean): true indicates that the grid should auto adapt its
 width, false that its width is fixed.
 Default : false
\end_layout

\begin_layout Description
setElasticView(int): Indicates which view should be elastic, which means
 that it will fill the remaining space once all other views are drawn.
 Default : -1 (none)
\end_layout

\begin_layout Description
setMaximumFetchCountAtAtime(int): Sets the maximum number that are returned
 at a time.
 It indicates how many items should be loaded.
 When the user scrolls, items to be displayed are fetched by groups of maximumFe
tchCountAtAtime items.
 A typical setting for this value is 1.5 the number of rows to be displayed
 at a time.
 (That is , the grid won't have to load items until the user scrolls) Default:25
\end_layout

\begin_layout Description
setRowsPerPage(int): Sets the number of row per page.
 A value of -1 indicates that all rows should fit on a single page.
 That does not mean they are all loaded at one time, since only the displayed
 rows are loaded, and updated when the user scrolls.
 Default : -1
\end_layout

\begin_layout Description
setSortIndex(int , boolean) : Sets the grid sorting.
 sortIndex : the column index by which the grid should be sorted ascending
 : indicates wether the sort should be performed in ascending or descending
 order
\end_layout

\begin_layout Description
setUserSortable(boolean): Sets wether the user can sort the grid by clicking
 on the column header.
 Default : true.
\end_layout

\begin_layout Description
setRenderOnload(boolean): Sets wether the grid content should be rendered
 as soon as the grid is displayed (attached on GWT panel)
\end_layout

\begin_layout Description
setRowSelector(String) Sets wether a row handle should be displayed.
 A row handle is a bar on the left side that allows the user to select a
 row without clicking on a particular cell (and without firing an oncellclick
 event).
 The given parameter is its size, in css units.
\end_layout

\begin_layout Paragraph
Adding / removing rows: 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Tatami Grid provides a simple way to manipulate rows.
 Once again, please refer to Grid MVC section for a more complete way to
 do that.
\end_layout

\begin_layout Standard
When you add or remove a row , the displayed grid is automatically updated
 and reflects the changes.
\end_layout

\begin_layout Standard
Example : 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Object[] row = {"Jane Doe" , "9876543210" , new Integer("1200") , new Date("11/1
2/1978") , "Developer" , Boolean.TRUE};
\end_layout

\begin_layout Plain Layout

grid.addRow(row);
\end_layout

\begin_layout Plain Layout

grid.removeRow(0);
\end_layout

\end_inset


\end_layout

\begin_layout Description
addRow(Object[]): Adds a row , taking each object from the array as the
 value for the corresponding column
\end_layout

\begin_layout Description
addRow(Object[],int
\begin_inset space ~
\end_inset

index): Same as previous, except that instead of adding it to the end of
 the grid, it adds it to the given index.
\end_layout

\begin_layout Description
removeRow(int): Removes the row at specified index
\end_layout

\begin_layout Description
addRow(Item): Delegates method for addItem in the underlying datastore.
 See DataStore and Items to learn how to manipulate Items directly
\end_layout

\begin_layout Description
addRow(Item , int): Same as previous , except that it adds it at the specified
 index
\end_layout

\begin_layout Description
removeRow(Item): Delegates method for removeItem in the underlying datastore.
 See DataStore and Items to learn how to manipulate Items directly
\end_layout

\begin_layout Description
getRowCount(): Returns the current row count
\end_layout

\begin_layout Paragraph
Adding / removing columns
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Columns can be added or removed at any time during grid lifecycle.
 To refresh the grid view (ie, how the columns are layed out), you must
 call the updateView() method.
\end_layout

\begin_layout Standard
For example, if we want to add a toggle button, to hide/show a column, we
 can code it just like that :
\begin_inset Quotes ers
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Button button = new Button("Toggle Phone Column");
\end_layout

\begin_layout Plain Layout

button.addClickListener(new ClickListener(){
\end_layout

\begin_layout Plain Layout

	private boolean isShown = true;
\end_layout

\begin_layout Plain Layout

	public void onClick(Widget sender){
\end_layout

\begin_layout Plain Layout

		if(isShown){
\end_layout

\begin_layout Plain Layout

			grid.removeColumn(1);
\end_layout

\begin_layout Plain Layout

			grid.updateView();
\end_layout

\begin_layout Plain Layout

			isShown = false;
\end_layout

\begin_layout Plain Layout

		}else{
\end_layout

\begin_layout Plain Layout

			grid.insertColumn("Phone Number" , 1); 
\end_layout

\begin_layout Plain Layout

			grid.updateView();
\end_layout

\begin_layout Plain Layout

			isShown = true;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

RootPanel.get().add(button);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we notice , those insertColumn and removeColumn methods take the column
 index as a parameter.
 
\end_layout

\begin_layout Standard
On the left, before hitting the button
\end_layout

\begin_layout Standard
On the right, after.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/grid_columnmanipulationexample.png

\end_inset


\end_layout

\begin_layout Description
addColumn(String
\begin_inset space ~
\end_inset

name): Adds a column with the specified name
\end_layout

\begin_layout Description
addColumn(String
\begin_inset space ~
\end_inset

name,String
\begin_inset space ~
\end_inset

fieldName): Adds a column with the specified name, which value is taken
 from the specified items attributes.
\end_layout

\begin_layout Description
addColumn(String,String,Formatter): Same as previous , except that you specify
 a Formatter , which is responsible for formatting the data to be displayed
 (See Formatting section)
\end_layout

\begin_layout Description
addColumn(String,String,GridEditor): Same as addColumn(String name, String
 fieldName), except that you specify an Editor, making this column editable
 (See Editing section)
\end_layout

\begin_layout Description
addColumn(String,String,GridEditor,Formatter): Same as the two previous
\end_layout

\begin_layout Description
addColumn(String,String,int): Same as addColumn(String name, String fieldName),
 except that you specify a cell width in pixel
\end_layout

\begin_layout Description
addColumn(String
\begin_inset space ~
\end_inset

name,GridEditor
\begin_inset space ~
\end_inset

editor,Formatter
\begin_inset space ~
\end_inset

formatter,String
\begin_inset space ~
\end_inset

width): Adds a column with the specified name, editor , formatter and width
 in standard css units (ex : “100px” , “10em”).
 Null values are accepted, except for width which could lead to strange
 behaviours
\end_layout

\begin_layout Description
addColumn(String
\begin_inset space ~
\end_inset

name,String
\begin_inset space ~
\end_inset

fieldName,String
\begin_inset space ~
\end_inset

width,GridEditor
\begin_inset space ~
\end_inset

editor,Formatter
\begin_inset space ~
\end_inset

formatter): Same as previous , except you specify the field name from which
 values should be taken
\end_layout

\begin_layout Description
addCell(Cell): Adds the specified cell as a column in the underlying GridView
 (See GridView and Cells)
\end_layout

\begin_layout Description
removeColumn(int): Removes the column at specified index
\end_layout

\begin_layout Description
removeColumn(Cell): Removes the specifided cell as a column in the underlying
 GridView (See GridView and Cells) 
\end_layout

\begin_layout Description
updateView(): Forces the grid to refresh its view, updating its columns
 definitions.
\end_layout

\begin_layout Paragraph
Paging
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Tatami’s grid supports two types of paging : the dojo’s one, which loads
 the grid rows as the user scrolls its grid, and a “previous page” / “next
 page” pagination.
\end_layout

\begin_layout Standard
This section will present you both, and how you can enable / disable any
 of them.
 
\end_layout

\begin_layout Subparagraph
Dojo’s “OnScroll” paging
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
To prevent massive requests to the datastore (which can be a remote datastore,
 requesting the server each time a fetch operation is performed), dojo provides
 an on scroll paging mechanism.
\end_layout

\begin_layout Standard
That means the grid will only fetch items that need to be displayed, by
 set of maximumFetchCountAtAtime.
 When the user scrolls the grid vertically, more rows need to be displayed
 , so the grid will fetch a new set of items.
\end_layout

\begin_layout Standard
This value is 25 by default , but we can specify it for the grid to be more
 efficient.
\end_layout

\begin_layout Standard
For example, if we know that we will always display 10 rows , setting the
 maximumFetchCountAtAtime to 20 will be sufficient to assure a quite reactive
 scrolling: the user will be able to scroll down the 10 next rows without
 a need for re-fetching data from the data store.
\end_layout

\begin_layout Standard
To perform this operation, just use the following method :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void setMaximumFetchCountAtAtime(int maximumFetchCountAtAtime) 
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Tatami pagination system
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
While dojo does not offer a “real” pagination system, one is built-in tatami’s
 grid.
 For using it, we just need to set the rowsPerPage parameter to something
 different from -1.
 
\end_layout

\begin_layout Standard
Example :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

grid.setRowsPerPage(50);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So, the grid will only display the first 50 rows, according to the specified
 order/filter.
\end_layout

\begin_layout Standard
Then if we want to turn pages, we just have to usse one of the following
 methods :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

grid.previousPage();
\end_layout

\begin_layout Plain Layout

grid.nextPage();
\end_layout

\begin_layout Plain Layout

grid.goToPage(int pageIndex);
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Pagination related Grid API
\end_layout

\begin_layout Description
getMaximumFetchCountAtAtime(): gets how much items should be loaded at a
 time (for onScroll paging)
\end_layout

\begin_layout Description
setMaximumFetchCountAtAtime(int): sets how much items should be loaded at
 a time (for onScroll paging)
\end_layout

\begin_layout Description
getRowsPerPage(): gets  the number of row to be displayed on each page
\end_layout

\begin_layout Description
setRowsPerPage(int): sets the number of row to be displayed on each page
\end_layout

\begin_layout Description
previousPage(): Go to previous page
\end_layout

\begin_layout Description
nextPage(): Go to next page
\end_layout

\begin_layout Description
goToPage(int): Go to the given page index
\end_layout

\begin_layout Paragraph
Filtering 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Tatami’s grid can easily perform filters.
 For now, it only supports exact-match filters but we expect to support
 regular expressions and simple mathematic operators in the future.
\end_layout

\begin_layout Subparagraph
How to filter a grid
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
To add a filter to the grid , just use :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void addFilter(String fieldName , String criterium)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where field name is the attribute on which we want to perform filtering,
 and criterium is the value that attribute has to match.
\end_layout

\begin_layout Standard
For example , it we filter the following grid : 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/grid_filteringexample.png

\end_inset


\end_layout

\begin_layout Standard
with the following filter:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

grid.addFilter("firstName","Jose");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It will result in :
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/grid_filteringexample2.png

\end_inset


\end_layout

\begin_layout Standard
Then , if we want to remove that filter, we can just use :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void removeFilter(String fieldName)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To remove the previous filter, we would use :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

grid.removeFilter("firstName"); 
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Filtering API
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Description
addFilter(String,Object): Adds a filter on given attribute which would be
 compared to given object
\end_layout

\begin_layout Description
removeFilter(String): Removes a filter on given attribute
\end_layout

\begin_layout Paragraph
Common issues while manipulating columns : introducing the MVC model.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
This section is intended to demonstrate some problems with the simplest
 column manipulation API, and to introduce to the solution.
\end_layout

\begin_layout Standard
We will start from the previous column manipulation example : 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Button button = new Button("Toggle Phone Column");
\end_layout

\begin_layout Plain Layout

button.addClickListener(new ClickListener(){
\end_layout

\begin_layout Plain Layout

	private boolean isShown = true;
\end_layout

\begin_layout Plain Layout

	public void onClick(Widget sender){
\end_layout

\begin_layout Plain Layout

		if(isShown){
\end_layout

\begin_layout Plain Layout

			grid.removeColumn(1);
\end_layout

\begin_layout Plain Layout

			grid.updateView();
\end_layout

\begin_layout Plain Layout

			isShown = false;
\end_layout

\begin_layout Plain Layout

		}else{
\end_layout

\begin_layout Plain Layout

			grid.insertColumn("Phone Number" , 1); 
\end_layout

\begin_layout Plain Layout

			grid.updateView();
\end_layout

\begin_layout Plain Layout

			isShown = true;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

RootPanel.get().add(button);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Suppose now that we want to insert it AFTER the Birthdate when the user
 clicks on the button again … We would probably be tempted to use the following
 snippet :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

}else{
\end_layout

\begin_layout Plain Layout

	grid.insertColumn("Phone Number" , 2);
\end_layout

\begin_layout Plain Layout

	grid.updateView();
\end_layout

\begin_layout Plain Layout

	isShown = true; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case, after the user hit the button a second time , the produced
 result would be :
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/grid_columnmanipulationtroubleexample.png

\end_inset


\end_layout

\begin_layout Standard
Why ? That’s because the only logical link between your data and your columns
 is their order … Because we specified an index of 2 for our column, it
 takes for it the data at index 2 from our rows, which is precisely the
 same as the birthdate column.
 We can also notice that the data from birthdate column has not changed
 : that’s because when it was created, it was told to use the data from
 field “2”.
\end_layout

\begin_layout Standard
If we want to solve this problem, we just can use the following method :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

grid.insertColumn("Phone Number" , "1", 2);
\end_layout

\begin_layout Plain Layout

grid.updateView();
\end_layout

\begin_layout Plain Layout

isShown = true;
\end_layout

\end_inset

 This method insert a column taking data from the field “1” , which was
 implicitly generated when you added your columns.
 To make it a bit cleaner , we will rewrite the base code for our grid :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Grid grid = new Grid(); 
\end_layout

\begin_layout Plain Layout

grid.addColumn("Name" , "name");
\end_layout

\begin_layout Plain Layout

grid.addColumn("Phone Number" , "number");
\end_layout

\begin_layout Plain Layout

grid.addColumn("BirthDate" , "birthdate"); 
\end_layout

\begin_layout Plain Layout

Object[] row1 = {"John Doe" , "0123456789" , new Date("03/25/1981") };
\end_layout

\begin_layout Plain Layout

Object[] row2 = {"Jane Doe" , "9876543210" , new Date("11/12/1978") };
\end_layout

\begin_layout Plain Layout

grid.addRow(row1);
\end_layout

\begin_layout Plain Layout

grid.addRow(row2);
\end_layout

\begin_layout Plain Layout

grid.setWidth("300px");
\end_layout

\begin_layout Plain Layout

grid.setHeight("200px");
\end_layout

\begin_layout Plain Layout

RootPanel.get().add(grid);
\end_layout

\begin_layout Plain Layout

Button button = new Button("Toggle Phone Column");
\end_layout

\begin_layout Plain Layout

button.addClickListener(new ClickListener(){
\end_layout

\begin_layout Plain Layout

	private boolean isShown = true;
\end_layout

\begin_layout Plain Layout

	public void onClick(Widget sender) {
\end_layout

\begin_layout Plain Layout

		if(isShown){
\end_layout

\begin_layout Plain Layout

		grid.removeColumn(1);
\end_layout

\begin_layout Plain Layout

		grid.updateView();
\end_layout

\begin_layout Plain Layout

		isShown = false;
\end_layout

\begin_layout Plain Layout

		}else{
\end_layout

\begin_layout Plain Layout

		grid.insertColumn("Phone Number" , "number" , 2);
\end_layout

\begin_layout Plain Layout

		grid.updateView();
\end_layout

\begin_layout Plain Layout

		isShown = true;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

RootPanel.get().add(button);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice the what has changed : we assigned a field name to the columns when
 we created them.
 Later, when we added our rows, the grid assigned field names to the various
 objects in the row according to the column’s order.
 Then , we can assign data to a column by its field name.
 That shows the limits of the simple grid utilisation … Please see Grid
 MVC section for a more powerful way of assigning columns and rows.
 
\end_layout

\begin_layout Subsubsection
Cell editing and formatting
\end_layout

\begin_layout Paragraph
Formatting
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
As we have seen earlier, some data need to be formatted for display.
 Tatami grid package offers only a Date formatter and a Currency formatter
 , but more are expected to come.
 You can also implement your own, by implementing the Formatter interface.
\end_layout

\begin_layout Subparagraph
How to use the date formatter
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Example for a Date formatter, using the example from previous section :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

grid.addColumn("Name" , "name");
\end_layout

\begin_layout Plain Layout

grid.addColumn("Phone Number" , "number");
\end_layout

\begin_layout Plain Layout

grid.addColumn("BirthDate" , "date" , new DateFormatter(DateFormatter.displayDateO
nly));
\end_layout

\begin_layout Plain Layout

grid.addColumn("Birth Time" , "date" , new DateFormatter(DateFormatter.displayTime
Only));
\end_layout

\begin_layout Plain Layout

grid.addColumn("Birth Year" , "date" , new DateFormatter("yyyy",null));
\end_layout

\begin_layout Plain Layout

grid.addColumn("Birth Day and Time" , "date" , new DateFormatter("mm:dd","hh:mm")
);
\end_layout

\begin_layout Plain Layout

grid.addColumn("Birth Time" , "date" , new DateFormatter(null , "hh"));
\end_layout

\begin_layout Plain Layout

Object[] row1 = {"John Doe" , "0123456789" , new Date("03/25/1981") };
\end_layout

\begin_layout Plain Layout

Object[] row2 = {"Jane Doe" , "9876543210" , new Date("11/12/1978")};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The above snippet will give the following output :
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/grid_formattingexample.png

\end_inset


\end_layout

\begin_layout Subparagraph
Date Formatter constructors: 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
DateFormatter(selector): Either DateFormatter.displayTimeAndDate, DateFormatter.di
splayTimeOnly , or DateFormatter.displayDateOnly.According to the constant,
 will display in the default locale time representation the date and the
 time, the date only , or the time only.
\end_layout

\begin_layout Standard
DateFormatter(datePattern , timePattern): Create a date formatter using
 the specified datePattern and timePattern.
 Date and Time pattern are specified as in ISO.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

formatter =new DateFormatter("dd/mm/yyyy" , null);
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

formatter=new DateFormatter(DateFormatter.displayDateOnly);
\end_layout

\begin_layout Plain Layout

formatter.setDatePattern("dd/mm/yyyy");
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Editing
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Tatami offers the same grid edition facility as Dojo Grid.
 That is, you can easily use one of the dojo editor to provide your grid
 in-place editing feature.
 User toggle editing by double-clicking on a grid cell.
\end_layout

\begin_layout Standard
All editors implement the GridEditor interface.
\end_layout

\begin_layout Subparagraph
Available editors :
\end_layout

\begin_layout Description
TextEditor: a simple text field
\end_layout

\begin_layout Description
DateEditor: a drop-down calendar 
\end_layout

\begin_layout Description
NumberSpinnerEditor: a simple spinner
\end_layout

\begin_layout Description
ComboBoxEditor: a drop-down list
\end_layout

\begin_layout Description
CheckBoxEditor: a checkbox for boolean values
\end_layout

\begin_layout Standard
Please refer to Javadoc for specific information about an editor.
 For the NumberSpinnerEditor, please refer to The NumberSpinner component
 section to see how to create it.
\end_layout

\begin_layout Standard
Sample :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

grid.addColumn("Name" , "name" , new TextEditor());
\end_layout

\begin_layout Plain Layout

grid.addColumn("Phone Number" , "number" , new TextEditor());
\end_layout

\begin_layout Plain Layout

grid.addColumn("Salary", "salary", new NumberSpinnerEditor( 0 , 1500 , 100));
\end_layout

\begin_layout Plain Layout

grid.addColumn("BirthDate" , "date" , new DateEditor() , new DateFormatter(DateFo
rmatter.displayDateOnly));
\end_layout

\begin_layout Plain Layout

String[] positions = {"CEO" , "Developer"};
\end_layout

\begin_layout Plain Layout

grid.addColumn("Position" , "position" , new ComboBoxEditor(positions));
\end_layout

\begin_layout Plain Layout

grid.addColumn("Available" , "available" , new CheckBoxEditor());
\end_layout

\begin_layout Plain Layout

Object[] row1 = {"John Doe" , "0123456789" , new Integer("500") , new Date("03/2
5/1981") , "CEO" , Boolean.FALSE};
\end_layout

\begin_layout Plain Layout

Object[] row2 = {"Jane Doe" , "9876543210" , new Integer("1200") , new Date("11/
12/1978") , "Developer" , Boolean.TRUE};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will give the following results, based on the cell on which you double-clic
ked:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/grid_editorsexample.png

\end_inset


\end_layout

\begin_layout Subsubsection
Grid events
\end_layout

\begin_layout Standard
The grid accepts GridListeners , which are notified when an event occurs
 on the grid.
 To observe those events, just implements the following interface :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface GridListener { 
\end_layout

\begin_layout Plain Layout

	public void onCellClick(Grid grid , int rowIndex , int colIndex String
 colName); 
\end_layout

\begin_layout Plain Layout

	public void onSelectionChanged(Grid grid); 
\end_layout

\begin_layout Plain Layout

	public void onDataChange(Grid grid , Item itemWhichChanged, String attributeNam
e, Object oldValue, Object newValue); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
onCellClick event will be fired each time a cell is clicked.
\end_layout

\begin_layout Itemize
onSelectionChange event will be fired each time the user selects (or unselects)
 a row, via a row click , or the classic SHIFT + click , CTRL + click selection
 combinations.
\end_layout

\begin_layout Itemize
onDataChange will be fired each time an item in the underlying store has
 changed.
 
\end_layout

\begin_layout Standard
For example, let’s write a simple grid observer to see how we can handle
 those events: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class myGridListener implements GridListener{
\end_layout

\begin_layout Plain Layout

	//The html which content will be changed each time a grid event occurs
\end_layout

\begin_layout Plain Layout

	private HTML html;
\end_layout

\begin_layout Plain Layout

	//What should be updated when a cell is clicked on.
 
\end_layout

\begin_layout Plain Layout

	private String lastClickedCellContent;
\end_layout

\begin_layout Plain Layout

	//What should be updated when the rows selection change
\end_layout

\begin_layout Plain Layout

	private String selectedIndexesCellContent;
\end_layout

\begin_layout Plain Layout

	//What should be displayed when an item's value changes
\end_layout

\begin_layout Plain Layout

	private String itemChangedContent;
\end_layout

\begin_layout Plain Layout

	//The constructor takes an "HTML" object in which it will write the cell
 content.
 
\end_layout

\begin_layout Plain Layout

	public myGridListener(HTML html){
\end_layout

\begin_layout Plain Layout

		this.html = html;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	//Updates the html object content
\end_layout

\begin_layout Plain Layout

	private void refresh(){
\end_layout

\begin_layout Plain Layout

		this.html.setText(lastClickedCellContent + "
\backslash
n" + selectedIndexesCellContent +"
\backslash
n" + itemChangedContent);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	//Updates the displayed text to show the content of the cell which has
 been clicked
\end_layout

\begin_layout Plain Layout

	public void onCellClick(Grid grid, int rowIndex , int colIndex , String
 colFieldName){
\end_layout

\begin_layout Plain Layout

		Object cellContent = grid.getItemFromRow(rowIndex).getValues(colFieldName);
\end_layout

\begin_layout Plain Layout

		lastClickedCellContent ="The last clicked cell contained : " + cellContent.toSt
ring();
\end_layout

\begin_layout Plain Layout

		this.refresh();
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

	//Updates the displayed text to show the selected rows indexes 
\end_layout

\begin_layout Plain Layout

	public void onSelectionChanged(Grid grid){
\end_layout

\begin_layout Plain Layout

		int[] indexes = grid.getSelectedIndexes();
\end_layout

\begin_layout Plain Layout

		selectedIndexesCellContent = "Selected rows : ";
\end_layout

\begin_layout Plain Layout

		for(int i = 0; i < indexes.length; i ++ ){
\end_layout

\begin_layout Plain Layout

			selectedIndexesCellContent += i +" ";
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		this.refresh();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	//Updates the displayed text to show how the data has changed in the grid
 
\end_layout

\begin_layout Plain Layout

	public void onDataChange(Grid grid , Item itemWhichChanged, String attributeNam
e, Object oldValue, Object newValue){
\end_layout

\begin_layout Plain Layout

		itemChangedContent = " The item at row " + grid.getRowFromItem(itemWhichChanged
) + " has changed.
 His attribute " + attributeName + " changed its value from " + oldValue.toString
() + " to "+ newValue.toString();
\end_layout

\begin_layout Plain Layout

		this.refresh();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

HTML html = new HTML();
\end_layout

\begin_layout Plain Layout

grid.addGridListener(new myGridListener(html));
\end_layout

\begin_layout Plain Layout

RootPanel.get().add(html);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After modifying the “John Doe” row , and selecting both rows (with CTRL
 + click) :
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/grid_listenerexample.png

\end_inset


\end_layout

\begin_layout Subsubsection
Advanced Grid usage
\end_layout

\begin_layout Paragraph
Datastore usage
\end_layout

\begin_layout Subparagraph
Introduction
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Tatami grid, just as dojo grid, relies on a data store.
 This data store is used to access the various items represented in the
 grid, and perform local operation like sorting , filtering … 
\end_layout

\begin_layout Standard
Whenever anything changes in the datastore, the grid updates itself according
 to those needs.
\end_layout

\begin_layout Standard
There are two principles you should be aware of:
\end_layout

\begin_layout Itemize
a row in the grid represents an item in the datastore 
\end_layout

\begin_layout Itemize
an item always has a unique identifier
\end_layout

\begin_layout Standard
You should see the DataStore Integration section on how to use it.
\end_layout

\begin_layout Subparagraph
Store-related Grid API
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Description
getStore(): Gets the grid datastore
\end_layout

\begin_layout Description
setStore(GridDataStore
\begin_inset space ~
\end_inset

store): Sets the grid datastore
\end_layout

\begin_layout Standard
The following methods add an item to the datastore, either directly or creating
 it from an array of object, positioning the item attributes accordingly
 to the declared columns fields:
\end_layout

\begin_layout Description
addRow(Item)
\end_layout

\begin_layout Description
addRow(Item,int)
\end_layout

\begin_layout Description
addRow(Object[])
\end_layout

\begin_layout Description
addRow(Object[],int)
\end_layout

\begin_layout Standard
The following methods remove an item from the datastore:
\end_layout

\begin_layout Description
removeRow(int)
\end_layout

\begin_layout Description
removeRow(Item)
\end_layout

\begin_layout Description
removeSelectedRows()
\end_layout

\begin_layout Paragraph
GridLayout, GridView and Cells
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
In the Adding / removing columns section , we saw how to create/modify a
 grid layout.
 
\end_layout

\begin_layout Standard
We also saw how this method was limited when we want to add/remove columns
 from a grid.
\end_layout

\begin_layout Standard
Tatami grid offers the same flexibility as dojo’s one to define how it should
 be layed out.
 
\end_layout

\begin_layout Subparagraph
How the grid layout is defined
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The schema below shows what objects are used to define a grid layout.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/grid_layoutdefinition.png

\end_inset


\end_layout

\begin_layout Standard
A layout is composed of one or several views (in red).
 Those views can be denifed as a set of columns.
 Each view can have its specific size, and its specific scrollbar(s).
 Of course, the vertical scrollbars are synchronized, since a grid row is
 defined among all views.
 Defining multiple views allows to have a fixed width view (not scrollable)
 while another view is scrollable.
 That can be useful to produce grid like this :
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/grid_multipleviewusage.png

\end_inset


\end_layout

\begin_layout Standard
The first column (name) is in its own (not scrollable) view, while other
 columns are grouped in another view.
 Thus, you can scroll through the columns while keeping the “Name” column
 in sight.
\end_layout

\begin_layout Standard
A view itself is composed of one or several rows of cells (in light green).
 Defining multiple cell-rows for a view is useful when you want to create
 sub-rows in the grid (look at the description field in the layout schema).
\end_layout

\begin_layout Standard
Those rows are composed of cells (in blue).
 The cell is the atomic entity of the layout.
 A cell is (at least) defined with the field used to fill its values and
 its name.
 If no field is provided, it will use the “value” setting to fill the cell.
\end_layout

\begin_layout Standard
Both cell and views have settings you can use to define their appearance
 and behavior.
 
\end_layout

\begin_layout Subparagraph
GridLayout usage
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Below is a simple sample showing how to create a GridLayout.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

GridLayout layout = new GridLayout();
\end_layout

\begin_layout Plain Layout

//Creating the first (left) view
\end_layout

\begin_layout Plain Layout

//This view contains only one cell, which label is "Name".
\end_layout

\begin_layout Plain Layout

//and wich content is the "myname" field from the data store objects.
\end_layout

\begin_layout Plain Layout

//This cell is also not resizable.
\end_layout

\begin_layout Plain Layout

//It also has a fixed width, and is not scrollable
\end_layout

\begin_layout Plain Layout

GridView view = new GridView();
\end_layout

\begin_layout Plain Layout

Cell cell = new Cell("myname" , "Name");
\end_layout

\begin_layout Plain Layout

cell.setIsNotResizable(Boolean.TRUE);
\end_layout

\begin_layout Plain Layout

view.addCellToLastRow(cell);
\end_layout

\begin_layout Plain Layout

view.setScrollable(false);
\end_layout

\begin_layout Plain Layout

view.setWidth("100px");
\end_layout

\begin_layout Plain Layout

//Creating the second (right) view
\end_layout

\begin_layout Plain Layout

//This view has 2 rows GridView
\end_layout

\begin_layout Plain Layout

view2 = new GridView();
\end_layout

\begin_layout Plain Layout

//We add a cell to the (current) last row
\end_layout

\begin_layout Plain Layout

view2.addCellToLastRow(new Cell("number" ,"Phone Number"));
\end_layout

\begin_layout Plain Layout

//We define a cell containing the salary attribute, and add it to the row
\end_layout

\begin_layout Plain Layout

//This cell is editable (with a number spinner)
\end_layout

\begin_layout Plain Layout

//and is formatted as a currency
\end_layout

\begin_layout Plain Layout

Cell salaryCell = new Cell("salary" ,"Salary");
\end_layout

\begin_layout Plain Layout

salaryCell.setEditor(new NumberSpinnerEditor());
\end_layout

\begin_layout Plain Layout

salaryCell.setFormatter(new CurrencyFormatter("EUR"));
\end_layout

\begin_layout Plain Layout

salaryCell.setWidth("50px");
\end_layout

\begin_layout Plain Layout

view2.addCellToLastRow(salaryCell);
\end_layout

\begin_layout Plain Layout

//We define a cell containt the date attribute, and add it to the row.
\end_layout

\begin_layout Plain Layout

//This cell is also editable (with a DateEditor) and is formatted as a date.
\end_layout

\begin_layout Plain Layout

//Please note that we define specific style settings for this cell
\end_layout

\begin_layout Plain Layout

Cell birthDateCell = new Cell("date" ,"Birthdate");
\end_layout

\begin_layout Plain Layout

birthDateCell.setEditor(new DateEditor());
\end_layout

\begin_layout Plain Layout

birthDateCell.setFormatter(new DateFormatter(DateFormatter.displayDateOnly));
\end_layout

\begin_layout Plain Layout

birthDateCell.setWidth("150px");
\end_layout

\begin_layout Plain Layout

birthDateCell.setCellStyles("text-align : right;");
\end_layout

\begin_layout Plain Layout

view2.addCellToLastRow(birthDateCell);
\end_layout

\begin_layout Plain Layout

//We define a cell containing the description
\end_layout

\begin_layout Plain Layout

//This cell will be added to a second row, and will have a colspan of 3
\end_layout

\begin_layout Plain Layout

Cell descriptionCell = new Cell("description" , "Description");
\end_layout

\begin_layout Plain Layout

descriptionCell.setColSpan(new Integer(3));
\end_layout

\begin_layout Plain Layout

view2.addCellToRow(descriptionCell, 1);
\end_layout

\begin_layout Plain Layout

//We define a cell containing the appreciation,and add it to the first row.
\end_layout

\begin_layout Plain Layout

//This cell has a rowspan of 2
\end_layout

\begin_layout Plain Layout

Cell appreciationCell = new Cell("appreciation" , "Mark");
\end_layout

\begin_layout Plain Layout

appreciationCell.setEditor(new NumberSpinnerEditor(0f , 10f, 0.5f));
\end_layout

\begin_layout Plain Layout

appreciationCell.setRowSpan(new Integer(2));
\end_layout

\begin_layout Plain Layout

view2.addCellToRow(appreciationCell,0);
\end_layout

\begin_layout Plain Layout

//We define a cell containing an constant value (an image) and add it just
 like the previous one
\end_layout

\begin_layout Plain Layout

Cell imageCell = new Cell("Send e-mail");
\end_layout

\begin_layout Plain Layout

imageCell.setDefaultValue("<img src='./mail-message-new.png' alt='send mail'></img>
");
\end_layout

\begin_layout Plain Layout

imageCell.setRowSpan(new Integer(2));
\end_layout

\begin_layout Plain Layout

view2.addCellToRow(imageCell,0);
\end_layout

\begin_layout Plain Layout

view2.setWidth("500px");
\end_layout

\begin_layout Plain Layout

//We add the views to the layout 
\end_layout

\begin_layout Plain Layout

layout.addView(view);
\end_layout

\begin_layout Plain Layout

layout.addView(view2);
\end_layout

\begin_layout Plain Layout

grid.setLayout(layout);
\end_layout

\begin_layout Plain Layout

grid.setAutoWidth(false);
\end_layout

\begin_layout Plain Layout

grid.setWidth("500px");
\end_layout

\begin_layout Plain Layout

grid.updateView();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The above code will produce the following layout :
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/grid_layoutexample.png

\end_inset


\end_layout

\begin_layout Subparagraph
GridLayout , GridView and Cell APIs
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
\size large
GridLayout API :
\end_layout

\begin_layout Description
addCellToLastView(Cell): Adds the given cell to the last row of the last
 view (useful when there is an only view)
\end_layout

\begin_layout Description
addCellToLastView(Cell, int): Adds the given cell at the specified index
 of the last row of the last view (useful when there is an only view)
\end_layout

\begin_layout Description
addView(GridView): Adds a view to the layout
\end_layout

\begin_layout Description
addView(int,GridView): Adds a view to the layout at the given index
\end_layout

\begin_layout Description
clear(): Removes all views from the layout
\end_layout

\begin_layout Description
getCellAmongAllViews(int): Gets a cell by its index among all views.
 That is, if the layout contains 2 views of 4 cells each, getCellAmongAllViews(4
) will return the cell at index 0 from the second view.
\end_layout

\begin_layout Description
getLastView(): Returns the last view from the layout
\end_layout

\begin_layout Description
getNbCells(): Returns the total number of cells defined in the layout
\end_layout

\begin_layout Description
getView(int): Returns the view at specified index
\end_layout

\begin_layout Description
removeCellAmongAllViews(Cell): Removes a cell wherever it is in the views
\end_layout

\begin_layout Description
removeView(GridView): Removes a view from the layout
\end_layout

\begin_layout Description
removeView(int): Removes the view at specified index
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
\size large
GridView API:
\end_layout

\end_deeper
\begin_layout Description
addCellToLastRow(Cell): Adds the given cell to the last row 
\end_layout

\begin_layout Description
addCellToLastRow(Cell,int): Adds the given cell at the specified index of
 the last row 
\end_layout

\begin_layout Description
addCellToRow(Cell,int
\begin_inset space ~
\end_inset

row):Adds the given cell to the given row.
 If this row doesn’t exist, it will be created.
\end_layout

\begin_layout Description
addCellToRow(Cell,int
\begin_inset space ~
\end_inset

row,int
\begin_inset space ~
\end_inset

index): Adds the given cell at the given index of the given row.
 If this row doesn’t exist, it will be created.
\end_layout

\begin_layout Description
clear(): Removes all rows from the view
\end_layout

\begin_layout Description
getCell(int): Gets a cell by its index among all rows.
 That is, if the view contains 2 rows of 4 cells each, getCell (4) will
 return the cell at index 0 from the second view.
\end_layout

\begin_layout Description
getCellFromRow(int row, int index): Returns the cell at the specified index
 from the specified row
\end_layout

\begin_layout Description
getNbCells(): Returns the total number of cells defined in the view
\end_layout

\begin_layout Description
getRow(int): Returns the row at specified index ( a row is a List of cells)
 
\end_layout

\begin_layout Description
getWidth(): Get the specified width in css units.
 If null, the view will be as wide as its containing cells.
\end_layout

\begin_layout Description
isScrollable(): Returns true if this view shows scrollbars, false othervwise
\end_layout

\begin_layout Description
removeCell(Cell): Removes the given cell
\end_layout

\begin_layout Description
removeCell(Cell, int): Removes the given cell from the given row
\end_layout

\begin_layout Description
removeCell(int): Removes the cell at given index (see getCell(int))
\end_layout

\begin_layout Description
removeCell(int row, int index): Removes the cell at given index from the
 given row.
\end_layout

\begin_layout Description
setScrollable(boolean): Sets if the view should display scrollbars
\end_layout

\begin_layout Description
setWidth(String): Sets the view width (in standard css units)
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
\size large
Cell API:
\series default
\size default

\begin_inset Newline newline
\end_inset

The following methods respectevely get/set the css classes or styles applied
 to a Cell:
\end_layout

\end_deeper
\begin_layout Description
getCellClasses()
\end_layout

\begin_layout Description
setCellClasses(String)
\end_layout

\begin_layout Description
getCellStyles()
\end_layout

\begin_layout Description
setCellStyles(String)
\end_layout

\begin_layout Standard
The following methods respectevely get/set the css classes or styles applied
 to the whole column (data and header):
\end_layout

\begin_layout Description
getClasses()
\end_layout

\begin_layout Description
setClasses(String)
\end_layout

\begin_layout Description
getStyles()
\end_layout

\begin_layout Description
setStyles(String)
\end_layout

\begin_layout Standard
The following methods respectively get/set the colspan (ie, the number of
 columns this cell should occupy)
\end_layout

\begin_layout Description
getColSpan():
\end_layout

\begin_layout Description
setColSpan(Integer)
\end_layout

\begin_layout Standard
The following methods respectively get/set the rowspan(ie, the number of
 rows this cell should occupy)
\end_layout

\begin_layout Description
getRowSpan()
\end_layout

\begin_layout Description
setRowSpan(Integer)
\end_layout

\begin_layout Standard
The following methods respectively get/set the cell default value (ie ,
 the value to be used when no field is assigned or when the underlying item
 doesn’t have the given field )
\end_layout

\begin_layout Description
getDefaultValue()
\end_layout

\begin_layout Description
setDefaultValue()
\end_layout

\begin_layout Standard
The following methods respectively get/set  this cell editor.
 If the editor is different from null, the cell will be editable.
 
\end_layout

\begin_layout Description
getEditor()
\end_layout

\begin_layout Description
setEditor(GridEditor)
\end_layout

\begin_layout Standard
The following methods respectively get/set the field from which this cell
 should fill its content.
 
\end_layout

\begin_layout Description
getField()
\end_layout

\begin_layout Description
setField(String)
\end_layout

\begin_layout Standard
The following methods respectively get/set whether this cell should not
 be resizable.
 If true, the cell will not be resizable.
 If false , it will be resizable.
 Default to true.
\end_layout

\begin_layout Description
getIsNotResizable()
\end_layout

\begin_layout Description
setIsNotResizable(Boolean)
\end_layout

\begin_layout Standard
The following methods respectively get/set this cell name (ie , what will
 be displayed on the column header)
\end_layout

\begin_layout Description
getName()
\end_layout

\begin_layout Description
setName(String)
\end_layout

\begin_layout Standard
The following methods respectively get/set the cell’s width in standard
 css units :
\end_layout

\begin_layout Description
getWidth()
\end_layout

\begin_layout Description
setWidth(String)
\end_layout

\begin_layout Subsection
Tree
\end_layout

\begin_layout Standard
Like the grid, the tree uses a datastore to store its items
\end_layout

\begin_layout Subsubsection
Getting Started
\end_layout

\begin_layout Standard
To use the tree, you need to import:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import com.objetdirect.tatami.client.tree.Tree;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The tree must be initialized with a root item, either directly in the constructo
r, or with the setRootItem method:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Tree tree = new Tree();
\end_layout

\begin_layout Plain Layout

tree.setRootItem(new Item("Item1","Item1"));
\end_layout

\begin_layout Plain Layout

//Or:
\end_layout

\begin_layout Plain Layout

tree = new Tree(new Item("Item1","Item1"));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Two other constructors are available if you do not want to use the default
 datastore: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public Tree(AbstractDataStore);
\end_layout

\begin_layout Plain Layout

public Tree(Item, AbstractDataStore);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, we will see how to populate such a tree: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Tree tree = new Tree(new Item("Root","Root"));
\end_layout

\begin_layout Plain Layout

Item item1 = new Item("item1" , "Item 1");
\end_layout

\begin_layout Plain Layout

Item item11 = new Item("item1.1" , "Item 1.1");
\end_layout

\begin_layout Plain Layout

Item item12 = new Item("item1.2" , "Item 1.2");
\end_layout

\begin_layout Plain Layout

item1.addChild(item11);
\end_layout

\begin_layout Plain Layout

item1.addChild(item12);
\end_layout

\begin_layout Plain Layout

item12.addChild(new Item("item1.2.1" , "Item 1.2.1"));
\end_layout

\begin_layout Plain Layout

item12.addChild(new Item("item1.2.2" , "Item 1.2.2"));
\end_layout

\begin_layout Plain Layout

tree.getRootItem().addChild(item1);
\end_layout

\begin_layout Plain Layout

tree.getRootItem().addChild(item2);
\end_layout

\begin_layout Plain Layout

RootPanel.get().add(tree);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/tree.png

\end_inset


\end_layout

\begin_layout Subsubsection
Customizing the tree display
\end_layout

\begin_layout Standard
The tree offers many customization options.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/treeExampleCustom.jpg

\end_inset


\end_layout

\begin_layout Standard
As you can see on the above picture, you can customize the icons used for
 items, as well as some css styling on the labels.
\end_layout

\begin_layout Standard
Customizing the icons can be done at two levels:
\end_layout

\begin_layout Itemize
setting default icons for the whole tree.
 This can be achieved by using the following methods.
 Those methods will take a string as an argument, which will be used as
 a css class to apply to the icon node.
\end_layout

\begin_layout Description
setDefaultFolderClosedClass(String): sets the class applied to a closed
 folder icon
\end_layout

\begin_layout Description
setDefaultFolderOpenClass(String): sets the class applied to an opened folder
 icon
\end_layout

\begin_layout Description
setDefaultLeafClass(String): sets the class applied to a tree leaf icon
 
\end_layout

\begin_deeper
\begin_layout Standard
The following example show how the icon classes were customized for the
 above tree:
\end_layout

\end_deeper
\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
tree.setDefaultFolderClosedClass("myTreeClosed");
\end_layout

\begin_layout Plain Layout
tree.setDefaultFolderOpenClass("myTreeOpened");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With the myTreeClosed and myTreeOpened class defined like this:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=HTML"
inline false
status open

\begin_layout Plain Layout
.tundra .myTreeOpened {
\end_layout

\begin_layout Plain Layout
	background-image: url('folder-open.png');
\end_layout

\begin_layout Plain Layout
	background-position: top;
\end_layout

\begin_layout Plain Layout
	top: 1px;
\end_layout

\begin_layout Plain Layout
	height: 32px !important;
\end_layout

\begin_layout Plain Layout
	width: 32px !important;
\end_layout

\begin_layout Plain Layout
}
\end_layout

\begin_layout Plain Layout
.tundra .myTreeClosed {
\end_layout

\begin_layout Plain Layout
	background-image: url('folder.png'); 
\end_layout

\begin_layout Plain Layout
	background-position: top; 
\end_layout

\begin_layout Plain Layout
	top: 1px; 
\end_layout

\begin_layout Plain Layout
	height: 32px !important; 
\end_layout

\begin_layout Plain Layout
	width: 32px !important; 
\end_layout

\begin_layout Plain Layout
}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
setting different icons for some items.
 This can be achieved by setting the Tree.folderClosedClassAttribute, Tree.folderO
penedClassAttribute or Tree.leafClassAttribute.
 
\end_layout

\begin_deeper
\begin_layout Standard
Example: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
item1.setValue(Tree.folderClosedClassAttribute,"item1");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With the item1 css class defined as:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
.item1{
\end_layout

\begin_layout Plain Layout
	background-image: 
\end_layout

\begin_layout Plain Layout
	url('folder-visiting.png');
\end_layout

\begin_layout Plain Layout
	background-position: top;
\end_layout

\begin_layout Plain Layout
	top: 1px;
\end_layout

\begin_layout Plain Layout
	height: 32px !important;
\end_layout

\begin_layout Plain Layout
	width: 32px !important;
\end_layout

\begin_layout Plain Layout
}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our item item1 will then have its own class:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/treeExampleCustom2.jpg

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
You can also customize the css styles applied to the label.
 As you probably noticed, item1 is the only one item which label is red-colored.
\end_layout

\begin_layout Standard
It has been achieved by using the following method:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
item1.setValue(Tree.labelClassAttribute,"myLabelClass");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With the corresponding css class:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
.myLabelClass{ 
\end_layout

\begin_layout Plain Layout
	color: red;
\end_layout

\begin_layout Plain Layout
}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Tree events
\end_layout

\begin_layout Standard
The Tree accepts tree listeners.
 A Tree Listener must implement the following interface:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
package com.objetdirect.tatami.client.tree;
\end_layout

\begin_layout Plain Layout
import com.objetdirect.tatami.client.data.Item;
\end_layout

\begin_layout Plain Layout
public interface TreeListener {
\end_layout

\begin_layout Plain Layout
	public void onClick(Item item); 
\end_layout

\begin_layout Plain Layout
	public void onOpen(Item item); 
\end_layout

\begin_layout Plain Layout
	public void onClose(Item item);
\end_layout

\begin_layout Plain Layout
	public void onDblClick(Item item); 
\end_layout

\begin_layout Plain Layout
}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, you can or remove tree listeners to a tree with the following methods:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
addTreeListener(TreeListener)
\end_layout

\begin_layout Plain Layout
removeTreeListener(TreeListener)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example
\end_layout

\begin_layout Standard
The following example illustrates the tree customization and tree listeners
 concepts.
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

FlowPanel panel = new FlowPanel(); 
\end_layout

\begin_layout Plain Layout

Tree tree = new Tree(new Item("Root","Root"));
\end_layout

\begin_layout Plain Layout

Item item1 = new Item("item1" , "Item 1");
\end_layout

\begin_layout Plain Layout

Item item11 = new Item("item1.1" , "Item 1.1");
\end_layout

\begin_layout Plain Layout

Item item12 = new Item("item1.2" , "Item 1.2");
\end_layout

\begin_layout Plain Layout

item1.addChild(item11);
\end_layout

\begin_layout Plain Layout

item1.addChild(item12);
\end_layout

\begin_layout Plain Layout

item12.addChild(new Item("item1.2.1" , "Item 1.2.1"));
\end_layout

\begin_layout Plain Layout

item12.addChild(new Item("item1.2.2" , "Item 1.2.2"));
\end_layout

\begin_layout Plain Layout

item1.setValue(Tree.labelClassAttribute,"myLabelClass");
\end_layout

\begin_layout Plain Layout

item1.setValue(Tree.folderClosedClassAttribute,"item1");
\end_layout

\begin_layout Plain Layout

Item item2 = new Item("item2" , "Item 2");
\end_layout

\begin_layout Plain Layout

tree.setDefaultFolderClosedClass("myTreeClosed");
\end_layout

\begin_layout Plain Layout

tree.setDefaultFolderOpenClass("myTreeOpened");
\end_layout

\begin_layout Plain Layout

tree.getRootItem().addChild(item1);
\end_layout

\begin_layout Plain Layout

tree.getRootItem().addChild(item2);
\end_layout

\begin_layout Plain Layout

final HTML openValue = new HTML("Opened :");
\end_layout

\begin_layout Plain Layout

final HTML closedValue = new HTML("Closed :");
\end_layout

\begin_layout Plain Layout

final HTML onClickValue = new HTML("Clicked :");
\end_layout

\begin_layout Plain Layout

final HTML onDblClickValue = new HTML("DblClicked :");
\end_layout

\begin_layout Plain Layout

panel.add(tree);
\end_layout

\begin_layout Plain Layout

tree.addTreeListener(new TreeListener() {
\end_layout

\begin_layout Plain Layout

	public void onOpen(Item item) {
\end_layout

\begin_layout Plain Layout

		openValue.setHTML("Opened :" + item.getId()); 
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	public void onClose(Item item) {
\end_layout

\begin_layout Plain Layout

		closedValue.setHTML("Closed :" + item.getId());
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

	public void onClick(Item item) {
\end_layout

\begin_layout Plain Layout

		onClickValue.setHTML("Clicked :" + item.getId());
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	public void onDblClick(Item item) { 
\end_layout

\begin_layout Plain Layout

		onDblClickValue.setHTML("DblClicked :" + item.getId()); 
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}); 
\end_layout

\begin_layout Plain Layout

panel.add(onClickValue);
\end_layout

\begin_layout Plain Layout

panel.add(onDblClickValue);
\end_layout

\begin_layout Plain Layout

panel.add(closedValue);
\end_layout

\begin_layout Plain Layout

panel.add(openValue);
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Datastore Integration
\end_layout

\begin_layout Section
DataStore and Items
\end_layout

\begin_layout Standard
The data store provides a convenient way to access data, locally or remotely.
 It is used in the grid and tree widgets to store their content.
\end_layout

\begin_layout Standard
A datastore contains Items
\end_layout

\begin_layout Standard
Items have an id attribute, which identifies them uniquely in the datastore.
\end_layout

\begin_layout Standard
To construct a DefaultDataStore , we simply have to the following constructor:
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

DefaultDataStore()
\end_layout

\end_inset


\end_layout

\begin_layout Section
Datastore usage
\end_layout

\begin_layout Standard
The following snippet shows how to build populate a DefaultDataStore :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

DefaultDataStore store = new DefaultDataStore();
\end_layout

\begin_layout Plain Layout

Item itemJohn = new Item();
\end_layout

\begin_layout Plain Layout

itemJohn.setId("14563" );
\end_layout

\begin_layout Plain Layout

itemJohn.setValue("myname", "John Doe" );
\end_layout

\begin_layout Plain Layout

itemJohn.setValue("number", "0123456789");
\end_layout

\begin_layout Plain Layout

itemJohn.setValue("salary", new Integer("500"));
\end_layout

\begin_layout Plain Layout

itemJohn.setValue("date", new Date("03/25/1981"));
\end_layout

\begin_layout Plain Layout

itemJohn.setValue("position", "CEO");
\end_layout

\begin_layout Plain Layout

itemJohn.setValue("available", Boolean.FALSE);
\end_layout

\begin_layout Plain Layout

itemJohn.setValue("mySecret", "!!!");
\end_layout

\begin_layout Plain Layout

itemJohn.setValue("description", "I m John Doe and this is my description"
 );
\end_layout

\begin_layout Plain Layout

itemJohn.setValue("appreciation", "Good" );
\end_layout

\begin_layout Plain Layout

itemJohn.setValue("married", true);
\end_layout

\begin_layout Plain Layout

store.add(itemJohn); 
\end_layout

\begin_layout Plain Layout

Item itemJane = new Item();
\end_layout

\begin_layout Plain Layout

itemJane.setId("87321" );
\end_layout

\begin_layout Plain Layout

itemJane.setValue("number", "9876543210");
\end_layout

\begin_layout Plain Layout

itemJane.setValue("salary", new Integer("1200"));
\end_layout

\begin_layout Plain Layout

itemJane.setValue("date", new Date("11/12/1978"));
\end_layout

\begin_layout Plain Layout

itemJane.setValue("position", "Developer");
\end_layout

\begin_layout Plain Layout

itemJane.setValue("available", Boolean.TRUE);
\end_layout

\begin_layout Plain Layout

itemJane.setValue("myname", "Jane Doe" );
\end_layout

\begin_layout Plain Layout

itemJane.setValue("description", "I m Jane Doe and this is my description"
 );
\end_layout

\begin_layout Plain Layout

itemJane.setValue("appreciation", "Awesome" );
\end_layout

\begin_layout Plain Layout

itemJane.setValue("mySecret", "!!!");
\end_layout

\begin_layout Plain Layout

itemJane.setValue("married", false );
\end_layout

\begin_layout Plain Layout

store.add(itemJane);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This store can then be used by a grid to populate itself..
\end_layout

\begin_layout Standard
Below is the datastore item manipulation API, which conforms to Dojo data
 APIs.
 
\end_layout

\begin_layout Description
addItem(Item): Adds an item to the datastore.
 If an item already has the same id, it is overridden.
 
\end_layout

\begin_layout Description
removeItem(Item): Removes an item from the data store
\end_layout

\begin_layout Description
getItemByIdentity(Object
\begin_inset space ~
\end_inset

id): Returns the item stored with the given id, null if no item within the
 store has the given attribute
\end_layout

\begin_layout Description
isItem(Object): true if item is an instance of Item and the store contains
 this item, false otherwise
\end_layout

\begin_layout Description
loadItem(Item): Loads the specified item if it has not already been.
 A “loaded” item should have all its attributes loaded, while a not-yet-loaded
 item can be a “stub” used for remote lazy loading.
 
\end_layout

\begin_layout Description
isItemLoaded(Item): Returns true if the given Item is in the store AND has
 been fully loaded.In the DefaultDataStore implementation, always returns
 true since we always add “fully loaded” items (no stubs, or remote lazy
 loading).
 (See How to implement your own data store )
\end_layout

\begin_layout Description
searchItemsByAttributes(String
\begin_inset space ~
\end_inset

attr,Object
\begin_inset space ~
\end_inset

value): Returns a list of items which given attribute attr has the given
 value.
\end_layout

\begin_layout Description
size(): Returns the number of items in the store.
\end_layout

\begin_layout Section
Fetching items
\end_layout

\begin_layout Standard
The core method of the datastore is the “fetch” function.
 The fetch function performs a query , represented by the “Request” object.
 
\end_layout

\begin_layout Standard
The fetch method signature :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void fetch(Request request)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This method performs a Request , and notifies the FetchListeners during
 the whole fetch process.
 
\end_layout

\begin_layout Standard
Below stands the Fetch Listener interface.
 The grid itself implements the FetchListener interface, but we can implement
 our own fetch listener to be aware of all the Fetch Process.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface FetchListener { 
\end_layout

\begin_layout Plain Layout

	public void onComplete(FetchEventSource source, List items , Request request
 ); 
\end_layout

\begin_layout Plain Layout

	public void onBegin(FetchEventSource source ,int size , Request request);
 
\end_layout

\begin_layout Plain Layout

	public void onItem(FetchEventSource source ,Item item); 
\end_layout

\begin_layout Plain Layout

	public void onError(FetchEventSource source); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The main method is onComplete : it is called once the fetch is done.
 Items is a List containing all the fetched items, while request is the
 (possibly modified) request performed.
\end_layout

\begin_layout Standard
onBegin is called before the actual fetch.
 “Size” is the total number of items matching the request (or the page size
 when using paging), while request is the (possibly modified) request performed.
\end_layout

\begin_layout Standard
onItem is called each time an Item has been fetched, that is , it will be
 present in the list passed to onComplete.
\end_layout

\begin_layout Standard
onError is called when an error occurs during the fetch.
\end_layout

\begin_layout Standard
The request object owns a certain amount of parameters, used to search items
 in the store.
 
\end_layout

\begin_layout Standard
These parameters are :
\end_layout

\begin_layout Description
nbItemToReturn: Maximum number of item to return.
 The number of item actually returned can be lesser than nbItemToReturn.
\end_layout

\begin_layout Description
startItemNumber: Specifies the item number from which the item should be
 returned.
 In particular, this is used to load only the number of items that fits
 on screen.
 (for example, this is what dojo specified to load the items as the user
 scrolls the grid)
\end_layout

\begin_layout Description
query: Map of key / attributes pair describing the search criterias.
 
\end_layout

\begin_layout Description
sortFields: A list of SortField.
 A SortField is a simple object containing an attribute name and a Boolean
 indicating wether the sort should be performed in ascending or descending
 order.
\end_layout

\begin_layout Section
DataStore events
\end_layout

\begin_layout Standard
Grid and datastores are connected via DataStore events.
 There are many events fired by the data store.
 In the previous section , we already saw how the fetch events are sourced
 and consumed.
\end_layout

\begin_layout Standard
Two other interfaces are defined to listen for DataStore events.
 Those are :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface LoadItemListener { public void onLoad(Item item); }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This interface defines a load item listener : the onLoad item will be called
 each time the datastore “loadItem” is called on an (not yet) loaded item.
 In the current implementation, the items are always already loaded , since
 we use no “stub” item.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface DatumChangeListener { 
\end_layout

\begin_layout Plain Layout

	public void onDataChange(Item item , String attributeName , Object oldValue
 , Object newValue);
\end_layout

\begin_layout Plain Layout

	public void onNew(Item item);
\end_layout

\begin_layout Plain Layout

	public void onDelete(Item item); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This interface defines a listener for data changes.
 For example, The grid itself implements this interface.
 onDataChange is called each time an item’s attribute has been modified.
 onNew is called each time an item has been added to the data store.
 onDelete is called each time an item has been deleted from the data store.
\end_layout

\begin_layout Description
addDatumChangeListener(DatumChangeListener): Adds a DatumChangeListener
\end_layout

\begin_layout Description
removeDatumChangeListener(DatumChangeListener): Removes a DatumChangeListener
\end_layout

\begin_layout Description
addFetchListener(FetchListener): Adds a FetchListener
\end_layout

\begin_layout Description
removeFetchListener(FetchListener): Removes a FetchListener
\end_layout

\begin_layout Description
addLoadItemListener(LoadItemListener): Adds a LoadItemListener
\end_layout

\begin_layout Description
removeLoadItemListener(LoadItemListener): Removes a LoadItemListener
\end_layout

\begin_layout Section
How to implement your own data store 
\end_layout

\begin_layout Subsection
Principles
\end_layout

\begin_layout Standard
Why implement your own data store ? The DefaultDataStore implementation
 is a purely local one.
 Of course , you can feed it with remotely aquired data, but if you want
 to only load items on demand, you would like to implement your own.
 We think it is the principal reason why you would like to implement one,
 but we are sure you will find plenty others !
\end_layout

\begin_layout Standard
To implement your own DataStore , you only have to subclass the DefaultDataStore
, and override the particular method you would like to implement yourself.
 The DefaultDataStore itself extends the AbstractDataStore class.
 
\end_layout

\begin_layout Subsection
Some examples
\end_layout

\begin_layout Standard
Suppose you would like to connect your grid directly to a relational database.
 Suppose also that this database is exposed via a REST-type web-service.
 The only thing you would have to override would be the fetch method.
 Please see the Fetching items section to understand how the items should
 be fetched.
\end_layout

\begin_layout Description
addItem(Item): Adds an item to the datastore.
 If an item already has the same id, it is overridden.
 
\end_layout

\begin_layout Description
removeItem(Item): Removes an item from the data store
\end_layout

\begin_layout Description
hasAttribute(Item item, String attr): Return true if the given attribute
 is specified for the given Item, false otherwise.
\end_layout

\begin_layout Description
getItemByIdentity(Object id): Returns the item stored with the given id,
 null if no item within the store has the given attribute
\end_layout

\begin_layout Description
isItem(Object): true if item is an instance of Item and the store contains
 this item, false otherwise
\end_layout

\begin_layout Description
loadItem(Item): Loads the specified item if it has not already been.
 A “loaded” item should have all its attributes loaded, while a not-yet-loaded
 item can be a “stub” used for remote lazy loading.
 
\end_layout

\begin_layout Description
isItemLoaded(Item): Returns true if the given Item is in the store AND has
 been fully loaded.
\end_layout

\begin_layout Description
searchItemsByAttributes(String attr, Object value): Returns a list of items
 which given attribute attr has the given value.
\end_layout

\begin_layout Description
setValue(Item, String attr, Object value): Sets the given value for the
 given attribute of the given item.
 If this attribute already exists , it is overridden.
\end_layout

\begin_layout Description
size(): Returns the number of items in the store.
\end_layout

\begin_layout Description
addDatumChangeListener(DatumChangeListener): Adds a DatumChangeListener
\end_layout

\begin_layout Description
removeDatumChangeListener(DatumChangeListener): Removes a DatumChangeListener
\end_layout

\begin_layout Description
addFetchListener(FetchListener): Adds a FetchListener
\end_layout

\begin_layout Description
removeFetchListener(FetchListener): Removes a FetchListener
\end_layout

\begin_layout Description
addLoadItemListener(LoadItemListener): Adds a LoadItemListener
\end_layout

\begin_layout Description
removeLoadItemListener(LoadItemListener): Removes a LoadItemListener
\end_layout

\begin_layout Chapter
Charting
\end_layout

\begin_layout Standard
Tatami also includes dojo’s simple and powerful charting system.
 It is located in the 
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

com.objetdirect.tatami.client.charting 
\end_layout

\end_inset

package.
 We advice you to take a look at the numerous chart examples in the TestPages
 module.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The Chart2D class is the widget component of the Charting system.
 To draw a chart, you have to follow those steps :
\end_layout

\begin_layout Enumerate
Create a Chart2D widget.
 This widget represents the whole chart.
\end_layout

\begin_layout Enumerate
Add (at least) a plot to this widget.
 The Plot type represents how the data are plotted, whereas the data itself
 is represented by the Serie object.
 Plot is a generic type, it should be parametrized with the type of data
 its series can accept.
 Use the following method in the Chart2D class : addPlot(Plot) See the Plot
 section for how to create a Plot.
\end_layout

\begin_layout Enumerate
Add series to the plots.
 Serie is a generic type, it should be parametrized with the type of data
 it can draw.
 Use the following method from the Plot class : addSerie(Serie)
\end_layout

\begin_layout Enumerate
(Optional) Add Axes to the Plot and / or to the chart.
 See the Axis section 
\end_layout

\begin_layout Enumerate
(Optional) Add Effects to the Plot.
 See the Effects section 
\end_layout

\begin_layout Enumerate
Render the chart.
 This is done automatically when you attach the chart to its parent.
 
\end_layout

\begin_layout Enumerate
(Optional) Update it's series as they are modified
\end_layout

\begin_layout Enumerate
(Optional) re-render the chart when modifying it's Axis, Plots, Effects
 … 
\end_layout

\begin_layout Standard

\emph on
If the chart is attached, any modification to the chart will have no effect
 until it is re-rendered !
\end_layout

\begin_layout Section
Getting started 
\end_layout

\begin_layout Standard
To build a chart, you need 3 objects : a Chart, a Plot and a Serie.
 Chart2D is the base class for a chart.
 It acts as a “container” in which Plots can be drawn.
 A plot is defined by its type (how are the data represented ?) and has
 series.
 A Serie is an object representing data to be plotted.
 
\end_layout

\begin_layout Standard
First, we have to create a chart.
 A chart must have a defined size, otherwise it will not be able to be rendered.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Chart2D chart = new Chart2D("200px", "200px");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, we must define a plot to be drawn on the chart:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Plot2D linePlot = new Plot2D(Plot2D.PLOT_TYPE_LINES);
\end_layout

\begin_layout Plain Layout

chart.addPlot(linePlot);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The plot type is defined in this constructor.
\end_layout

\begin_layout Standard
The possible values are contained in the Plot, Plot2D, BarPlot and PiePlot
 classes.
\end_layout

\begin_layout Standard
We will explain this later in the Plot types section.
\end_layout

\begin_layout Standard
Now that we have a plot defined in the chart, we have to feed it with some
 data.
\end_layout

\begin_layout Standard
The Serie object acts as a container for data.
\end_layout

\begin_layout Standard
The Serie class has a constructor defined like this :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/** 
\end_layout

\begin_layout Plain Layout

* A serie contains data, stored as a List.
 
\end_layout

\begin_layout Plain Layout

* This data can be : a Number, a Point , a Bubble 
\end_layout

\begin_layout Plain Layout

* or a PiePiece , depending on the chart type 
\end_layout

\begin_layout Plain Layout

* @param data : the data to plot on the chart 
\end_layout

\begin_layout Plain Layout

*/ 
\end_layout

\begin_layout Plain Layout

public Serie(List<T> data) ;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We build a new Serie object and add it to the chart.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Double[]data3 = new Double[]{6.3, 1.8, 3., 0.5, 4.4, 2.7, 2.};
\end_layout

\begin_layout Plain Layout

Serie<Double> mySerie1 = new Serie<Double>(Arrays.asList(data1)); 
\end_layout

\begin_layout Plain Layout

linePlot.addSerie(mySerie1);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, we can add the chart to the page :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

RootPanel.get().add(chart);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Please note that attaching the chart to the page automatically calls the
 refreshChart method.
 You always can refresh the chart by calling 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void refreshChart()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This complete code will output the following chart :
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/gettingstarted_example.png

\end_inset


\end_layout

\begin_layout Standard
This chart is not very expressive … We will see how to customize its appearance,
 add axes, legend, effects …
\end_layout

\begin_layout Section
Plot types
\end_layout

\begin_layout Standard
The charting system allows several type of plots.
 All plots type do not accept any type of series.
\end_layout

\begin_layout Standard
There are a few number of Plot classes available.
\end_layout

\begin_layout Subsection
Plot2D
\end_layout

\begin_layout Standard
This class is used to draw several types of two dimensional plots.
 
\end_layout

\begin_layout Subsubsection
What type of data to use?
\end_layout

\begin_layout Standard
This type of plot can be used with series of anything which extends Number,
 or with the Point object.
 When using numbers, the X coordinate is the position of the number in the
 list.
 When using Points, both X and Y coordinates must be specified.
 
\end_layout

\begin_layout Standard
Ex :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Serie<Point> serie1 = new Serie<Point>();
\end_layout

\begin_layout Plain Layout

serie1.addData(new Point(3.,2.)); 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Subtypes 
\end_layout

\begin_layout Standard
The plot type is determined with the constructor: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public Plot2D(String type) ; 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Where type is one of the following constants : 
\end_layout

\begin_layout Description
Plot2D.PLOT_TYPE_LINES Series are drawn as lines Ex: 
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename images/chartingimages/plot2D_typelinesaxample.png

\end_inset


\end_layout

\begin_layout Description
Plot2D.PLOT_TYPE_AREAS Series are drawn as lines, and the area under lines
 is filled.
 Ex : 
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename images/chartingimages/plot2D_typeareasaxample.png

\end_inset


\end_layout

\begin_layout Description
Plot2D.PLOT_TYPE_MARKERS_LINES Series are drawn as lines, with markers on
 the actual points Ex:
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename images/chartingimages/plot2D_typemarkerlinesaxample.png

\end_inset


\end_layout

\begin_layout Description
Plot2D.PLOT_TYPE_SCATTER Series are drawn as points only Ex:
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename images/chartingimages/plot2D_typescatterxample.png

\end_inset


\end_layout

\begin_layout Description
Plot2D.PLOT_TYPE_LINES_STACKED Series are drawn as lines and the y positions
 are additive.
 Ex:
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename images/chartingimages/plot2D_typestackedlinesaxample.png

\end_inset


\end_layout

\begin_layout Description
Plot2D.PLOT_TYPE_AREAS_STACKED Series are drawn as lines, the area beneath
 is filled and the y positions are additive.
 Ex:
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename images/chartingimages/plot2D_typestackedareasaxample.png

\end_inset


\end_layout

\begin_layout Subsubsection
Specific options 
\end_layout

\begin_layout Description
Tension: It allows you to add some curve to the lines 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void setTension(String tension);
\end_layout

\end_inset

Example with tension = 2 :
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Plot2D plot = new Plot2D(Plot2D.PLOT_TYPE_MARKERS_LINES);
\end_layout

\begin_layout Plain Layout

plot.setTension("2");
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Graphics
	filename images/chartingimages/plot2D_tensionExample.png

\end_inset


\end_layout

\begin_layout Description
Shadow: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

* Creates a shadow 
\end_layout

\begin_layout Plain Layout

*bubbles
\end_layout

\begin_layout Plain Layout

* @param width : the shadow's width 
\end_layout

\begin_layout Plain Layout

* @param dx : shadow's x position from the line 
\end_layout

\begin_layout Plain Layout

* @param dy : shadow's y position from the line 
\end_layout

\begin_layout Plain Layout

*/ 
\end_layout

\begin_layout Plain Layout

public void setShadow(int width, int dx, int dy);
\end_layout

\end_inset

Example : 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Plot2D<Double> plot = new Plot2D<Double>(Plot2D.PLOT_TYPE_LINES_STACKED);
\end_layout

\begin_layout Plain Layout

plot.setShadow(2, 2, 2);
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Graphics
	filename images/chartingimages/plot2D_shadowExample.png

\end_inset


\end_layout

\begin_layout Description
ShowMarkers: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

* @param show : Set wether to show the markers or not.
\end_layout

\begin_layout Plain Layout

* Overrides the default "PLOT_TYPE" behavior.
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

public void setShowMarkers(boolean show);
\end_layout

\end_inset


\end_layout

\begin_layout Description
ShowLines: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/** 
\end_layout

\begin_layout Plain Layout

* @param show : Set wether to show the markers or not.
\end_layout

\begin_layout Plain Layout

* Overrides the default "PLOT_TYPE" behavior.
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

public void setShowLines(boolean show); 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
BubblePlot: 
\end_layout

\begin_layout Standard
The BubblePlot class is a Chart2D subclass.
 It is used to represent data as “Bubbles”, defined by their coordinates
 and radius.
 It has its own class, since it uses specific data objects : bubbles.
 The bubble plot is used with series of Bubble object : 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public Bubble(double x, double y ,double size);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Bubble[] bubbles = new Bubble[]{new Bubble(0.3,8,2.5),new Bubble(4,6,1.1),new
 Bubble(5.5,2,3.2)};
\end_layout

\begin_layout Plain Layout

Serie<Bubble> serie = new Serie<Bubble>(Arrays.asList(bubbles));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/bubbleplot_example.png

\end_inset


\end_layout

\begin_layout Subsection
BarPlot
\end_layout

\begin_layout Standard
This class is used to draw several types of Bar and Columbs plots
\end_layout

\begin_layout Subsubsection
What type of data to use?
\end_layout

\begin_layout Standard
This type of plot can be used with series of anything wich extends Number.
 The y coordinate is the number, where the x coordinate is the data’s position
 in the Serie.
\end_layout

\begin_layout Subsubsection
Subtypes
\end_layout

\begin_layout Standard
.
 The plot type is determined with the constructor: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public BarPlot(String type) ; 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Where type is one of the following constants :
\end_layout

\begin_layout Description
BarPlot.PLOT_TYPE_BARS: Series are drawn in horizontal bars.
 Ex:
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename images/chartingimages/bar_barsexample.png

\end_inset


\end_layout

\begin_layout Description
BarPlot.PLOT_TYPE_COLUMNS: Series are drawn in vertical bars.
 Ex:
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename images/chartingimages/bar_columnsexample.png

\end_inset


\end_layout

\begin_layout Description
BarPlot.PLOT_TYPE_BARS_STACKED: Series are drawn in stacked horizontal bars,
 adding the bars values from one serie to the next.
 Ex:
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename images/chartingimages/bar_stackedbarsexample.png

\end_inset


\end_layout

\begin_layout Description
BarPlot.PLOT_TYPE_COLUMNS_STACKED Same as BARS_STACKED, but with vertical
 bars.
 Ex:
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename images/chartingimages/bar_stackedcolumnsexample.png

\end_inset


\end_layout

\begin_layout Description
BarPlot.PLOT_TYPE_BARS_CLUSTERED: Bars which do not overlap.
 Ex:
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename images/chartingimages/bar_clusteredbarsexample.png

\end_inset


\end_layout

\begin_layout Description
BarPlot.PLOT_TYPE_COLUMNS_CLUSTERED: Columns which do not overlap.
 Ex: 
\end_layout

\begin_layout Description
\begin_inset Graphics
	filename images/chartingimages/bar_clusteredcolumnsexample.png

\end_inset


\end_layout

\begin_layout Subsubsection
Specific options
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

* @param gap : sets the gap between two bars 
\end_layout

\begin_layout Plain Layout

*/ 
\end_layout

\begin_layout Plain Layout

public void setGap(int gap);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ex: Clustered Columns with gap = 10 :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Chart2D chart = new Chart2D("400px", "200px");
\end_layout

\begin_layout Plain Layout

BarPlot plot = new BarPlot(BarPlot.PLOT_TYPE_COLUMNS_CLUSTERED);
\end_layout

\begin_layout Plain Layout

plot.setGap(10);
\end_layout

\begin_layout Plain Layout

chart.addPlot(plot);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/bar_gapexample.png

\end_inset


\end_layout

\begin_layout Subsection
PiePlot
\end_layout

\begin_layout Subsubsection
What type of data to use? 
\end_layout

\begin_layout Standard
The PiePlot can be used with series of number or PiePiece.
 A PiePiece represents slice in the Pie Plot, and provides various constructors:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public PiePiece(double value)
\end_layout

\begin_layout Plain Layout

public PiePiece(double value , String label)
\end_layout

\begin_layout Plain Layout

public PiePiece(double value , String label,String color)
\end_layout

\begin_layout Plain Layout

public PiePiece(double value , String label,String color, String fontColor);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where : 
\end_layout

\begin_layout Description
value: the PiePiece value 
\end_layout

\begin_layout Description
label: the label to be displayed on the Piece 
\end_layout

\begin_layout Description
color: the color filling the piece 
\end_layout

\begin_layout Description
fontColor: the label font color
\end_layout

\begin_layout Subsubsection
Specific options
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

* @param offset : the label position from the edge of the plot 
\end_layout

\begin_layout Plain Layout

* Negative values will place the label outside of the plot, whereas positive
 values will place in inside 
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

public void setLabelOffset(int offset)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/** 
\end_layout

\begin_layout Plain Layout

* @param precision : the precision for percentiles 
\end_layout

\begin_layout Plain Layout

*/ 
\end_layout

\begin_layout Plain Layout

public void setPrecision(int precision)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/** 
\end_layout

\begin_layout Plain Layout

* @param font : font to be applied on the various labels 
\end_layout

\begin_layout Plain Layout

*/ 
\end_layout

\begin_layout Plain Layout

public void setFont(String font) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

* @param fontColor : default font color.
 Can be overriden by each PiePiece
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

public void setFontColor(String fontColor)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Examples :
\end_layout

\begin_layout Standard
Pie chart from a Number Serie, with internal labels and default Precision
 :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Chart2D chart = new Chart2D("300px","300px");
\end_layout

\begin_layout Plain Layout

chart.setTheme("PlotKit.blue");
\end_layout

\begin_layout Plain Layout

PiePlot<Integer> plot = new PiePlot<Integer>();
\end_layout

\begin_layout Plain Layout

plot.setFont("normal normal bold 12pt Tahoma");
\end_layout

\begin_layout Plain Layout

plot.setFontColor("white");
\end_layout

\begin_layout Plain Layout

plot.setLabelOffset(40);
\end_layout

\begin_layout Plain Layout

List<Integer> data = Arrays.asList((new Integer[]{4,2,1,1}));
\end_layout

\begin_layout Plain Layout

plot.addSerie(new Serie<Integer>(data));
\end_layout

\begin_layout Plain Layout

chart.addPlot(plot);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/pieplot_example1.png

\end_inset


\end_layout

\begin_layout Standard
Pie chart from a Number Serie, with external labels and precision = 0 :
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Chart2D chart = new Chart2D("300px","300px"); 
\end_layout

\begin_layout Plain Layout

chart.setTheme("PlotKit.blue"); 
\end_layout

\begin_layout Plain Layout

PiePlot<Integer> plot = new PiePlot<Integer>(); 
\end_layout

\begin_layout Plain Layout

plot.setFont("normal normal bold 12pt Tahoma");
\end_layout

\begin_layout Plain Layout

plot.setFontColor("black");
\end_layout

\begin_layout Plain Layout

plot.setLabelOffset(-25);
\end_layout

\begin_layout Plain Layout

plot.setPrecision(0);
\end_layout

\begin_layout Plain Layout

plot.addSerie(new Serie<Integer>(Arrays.asList(new Integer[]{4,2,1,1})));
\end_layout

\begin_layout Plain Layout

chart.addPlot(plot); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/pieplot_example2.png

\end_inset


\end_layout

\begin_layout Section
Axes
\end_layout

\begin_layout Standard
The charting API offers numerous options for customizing Axis.
\end_layout

\begin_layout Subsection
Setting axis 
\end_layout

\begin_layout Standard
Axis can be set at the chart or at the plot level.
 Axis set at the chart level will be used by all plots which don’t have
 any specific axis.
 
\end_layout

\begin_layout Standard
To set the default X and Y axis, use the following methods from the Chart2D
 class :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void setDefaultXAxis(Axis axis);
\end_layout

\begin_layout Plain Layout

public void setDefaultYAxis(Axis axis);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Axis class provides two constructors :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/** 
\end_layout

\begin_layout Plain Layout

* Constructs a default bottom horizontal axis 
\end_layout

\begin_layout Plain Layout

*/ 
\end_layout

\begin_layout Plain Layout

public Axis();
\end_layout

\begin_layout Plain Layout

/** 
\end_layout

\begin_layout Plain Layout

* @param position : an int representing the Axis position.
 
\end_layout

\begin_layout Plain Layout

* It is obtained from int byte to byte OR operation between the following
 constants :
\end_layout

\begin_layout Plain Layout

* 
\end_layout

\begin_layout Plain Layout

* Axis.LEFT 
\end_layout

\begin_layout Plain Layout

* Axis.RIGHT 
\end_layout

\begin_layout Plain Layout

* Axis.BOTTOM 
\end_layout

\begin_layout Plain Layout

* Axis.TOP 
\end_layout

\begin_layout Plain Layout

* Axis.VERTICAL 
\end_layout

\begin_layout Plain Layout

* Axis.HORIZONTAL 
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

public Axis(int position) ;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example, a right vertical axis would be created as :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

new Axis(Axis.RIGHT | Axis.VERTICAL); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Axis class also proposes two helper methods to get a bottom X axis and
 a left Y Axis :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/** 
\end_layout

\begin_layout Plain Layout

* @return a default horizontal axis instance 
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

public static Axis simpleXAxis() 
\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

* @return a default vertical axis instance 
\end_layout

\begin_layout Plain Layout

*/ 
\end_layout

\begin_layout Plain Layout

public static Axis simpleYAxis() 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following snippet can then be used to provide simple axes to your charts
 :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

chart.setDefaultXAxis(Axis.simpleXAxis());
\end_layout

\begin_layout Plain Layout

chart.setDefaultYAxis(Axis.simpleYAxis()); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To set axes for a specific plot, you can use the Plot methods 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void setXAxis(Axis axis);
\end_layout

\begin_layout Plain Layout

public void setYAxis(Axis axis);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Below is an example of two plots on the same chart with different axes :
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Chart2D chart = new Chart2D("500px","500px");
\end_layout

\begin_layout Plain Layout

//Constructing the Column plot
\end_layout

\begin_layout Plain Layout

BarPlot<Integer> columns = new BarPlot<Integer>(BarPlot.PLOT_TYPE_COLUMNS);
 
\end_layout

\begin_layout Plain Layout

//Constructing its serie
\end_layout

\begin_layout Plain Layout

Serie<Integer> columnsSerie = new Serie<Integer>();
\end_layout

\begin_layout Plain Layout

columnsSerie.addData(4);
\end_layout

\begin_layout Plain Layout

columnsSerie.addData(3);
\end_layout

\begin_layout Plain Layout

columnsSerie.addData(2);
\end_layout

\begin_layout Plain Layout

columnsSerie.addData(5);
\end_layout

\begin_layout Plain Layout

columnsSerie.addData(1); 
\end_layout

\begin_layout Plain Layout

//Simple Serie options, see the "Series" section for more info
\end_layout

\begin_layout Plain Layout

columnsSerie.setFillColor("blue"); 
\end_layout

\begin_layout Plain Layout

//We add the serie to the column plot 
\end_layout

\begin_layout Plain Layout

columns.addSerie(columnsSerie); 
\end_layout

\begin_layout Plain Layout

//Constructing the line plot 
\end_layout

\begin_layout Plain Layout

Plot2D<Point> lines = new Plot2D<Point>(Plot2D.PLOT_TYPE_MARKERS_LINES);
 
\end_layout

\begin_layout Plain Layout

//Constructing its series from points 
\end_layout

\begin_layout Plain Layout

Serie<Point> linesSerie = new Serie<Point>(); 
\end_layout

\begin_layout Plain Layout

linesSerie.addData(new Point(12.,41.));
\end_layout

\begin_layout Plain Layout

linesSerie.addData(new Point(25.,68.));
\end_layout

\begin_layout Plain Layout

linesSerie.addData(new Point(48.,21));
\end_layout

\begin_layout Plain Layout

linesSerie.addData(new Point(72,10)); 
\end_layout

\begin_layout Plain Layout

linesSerie.addData(new Point(121,142)); 
\end_layout

\begin_layout Plain Layout

//Simple Serie options, see the "Series" section for more info 
\end_layout

\begin_layout Plain Layout

linesSerie.setStrokeColor("red"); 
\end_layout

\begin_layout Plain Layout

//We add the serie to the column plot lines.addSerie(linesSerie); 
\end_layout

\begin_layout Plain Layout

//The plot are added to the chart 
\end_layout

\begin_layout Plain Layout

chart.addPlot(lines); 
\end_layout

\begin_layout Plain Layout

chart.addPlot(columns); 
\end_layout

\begin_layout Plain Layout

//The chart will have default X and Y axis 
\end_layout

\begin_layout Plain Layout

chart.setDefaultXAxis(Axis.simpleXAxis());
\end_layout

\begin_layout Plain Layout

chart.setDefaultYAxis(Axis.simpleYAxis()); 
\end_layout

\begin_layout Plain Layout

/* We override this setting for the line plot 
\end_layout

\begin_layout Plain Layout

* The getLineXAxis and getLineYAxis are not shown 
\end_layout

\begin_layout Plain Layout

* here, but will be presented in the "Axis options" section.
 
\end_layout

\begin_layout Plain Layout

* They only return new, customized for the example, axis.
 
\end_layout

\begin_layout Plain Layout

*/ 
\end_layout

\begin_layout Plain Layout

lines.setXAxis(getLineXAxis());
\end_layout

\begin_layout Plain Layout

lines.setYAxis(getLineYAxis());
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/axes_example1.png

\end_inset


\end_layout

\begin_layout Subsection
Axis Options
\end_layout

\begin_layout Standard
The precedent example shows how axis can be customized.
 There are a lot of options for Axis … 
\end_layout

\begin_layout Subsubsection
Ticks Options
\end_layout

\begin_layout Standard
Axes can show up to 3 different kinds of ticks: major minor, and micro.
 You can enable/disable them with the corresponding methods : 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void setMinorTicks(Boolean minorTicks);
\end_layout

\begin_layout Plain Layout

public void setMajorTicks(Boolean majorTicks);
\end_layout

\begin_layout Plain Layout

public void setMajorTicks(Boolean microTicks);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each of these ticks types have different options: 
\end_layout

\begin_layout Description
length: the length of the ticks, in pixels
\end_layout

\begin_layout Description
color: the color of the ticks
\end_layout

\begin_layout Description
step: the step between the ticks
\end_layout

\begin_layout Standard
The corresponding methods names are pretty straightforward: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

setMajorTicksColor(String)
\end_layout

\begin_layout Plain Layout

setMajorTicksLength(double)
\end_layout

\begin_layout Plain Layout

setMajorTickStep(double)
\end_layout

\begin_layout Plain Layout

setMinorTicksColor(String)
\end_layout

\begin_layout Plain Layout

setMinorTicksLength(double)
\end_layout

\begin_layout Plain Layout

setMicroTickStep(double)
\end_layout

\begin_layout Plain Layout

setMicroTicksColor(String)
\end_layout

\begin_layout Plain Layout

setMicroTicksLength(double)
\end_layout

\begin_layout Plain Layout

setMicroTickStep(double)
\end_layout

\end_inset

Minor and Major ticks can also show labels :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

setMajorLabels(Boolean)
\end_layout

\begin_layout Plain Layout

setMinorLabels(Boolean)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example : 
\end_layout

\begin_layout Standard
The following example demonstrates the use of ticks options.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Axis xLinesAxis = new Axis(Axis.BOTTOM | Axis.HORIZONTAL);
\end_layout

\begin_layout Plain Layout

xLinesAxis.setMajorTickStep(50);
\end_layout

\begin_layout Plain Layout

xLinesAxis.setMajorTicksLength(15);
\end_layout

\begin_layout Plain Layout

xLinesAxis.setMajorTicksColor("blue");
\end_layout

\begin_layout Plain Layout

xLinesAxis.setMinorTickStep(20);
\end_layout

\begin_layout Plain Layout

xLinesAxis.setMinorTicksLength(10);
\end_layout

\begin_layout Plain Layout

xLinesAxis.setMinorLabels(true);
\end_layout

\begin_layout Plain Layout

xLinesAxis.setMinorTicksColor("red");
\end_layout

\begin_layout Plain Layout

xLinesAxis.setMicroTicks(true);
\end_layout

\begin_layout Plain Layout

xLinesAxis.setMicroTickStep(10);
\end_layout

\begin_layout Plain Layout

xLinesAxis.setMicroTicksLength(5);
\end_layout

\begin_layout Plain Layout

xLinesAxis.setMicroTicksColor("green");
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Miscellaneous options
\end_layout

\begin_layout Standard
This set of options allow you to customize some axis properties such as
 its minimum and maximum, if it should be aligned on ticks etc...
\end_layout

\begin_layout Description
setIncludeZero(Boolean): sets whether the axis should be forced to include
 the zero.
 
\end_layout

\begin_layout Description
setMax(double): sets the maximum value displayed on the axis 
\end_layout

\begin_layout Description
setMin(double): sets the minimum value displayed on the axis
\end_layout

\begin_layout Description
setNatural(boolean): forces the ticks to be aligned on natural numbers 
\end_layout

\begin_layout Description
setFixed(Boolean): sets whether the labels precision is fixed 
\end_layout

\begin_layout Description
setFont(String): sets the font used for the labels
\end_layout

\begin_layout Description
setFontColor(String): sets the font color used for the labels
\end_layout

\begin_layout Description
setFixLower(String): forces the lower axis bound to be aligned on a tick.
 Possible values are : AXIS.FIX_TYPE_MAJOR, AXIS.FIX_TYPE_MINOR, AXIS.FIX_TYPE_MICR
O 
\end_layout

\begin_layout Description
setFixUpper(String) : same as setFixLower, but for the upper bound.
\end_layout

\begin_layout Standard
Example :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xLinesAxis.setFixed(true);
\end_layout

\begin_layout Plain Layout

xLinesAxis.setFixLower(Axis.FIX_TYPE_MAJOR);
\end_layout

\begin_layout Plain Layout

xLinesAxis.setFixUpper(Axis.FIX_TYPE_MICRO);
\end_layout

\begin_layout Plain Layout

xLinesAxis.setFont("normal normal bold 12pt Tahoma");
\end_layout

\begin_layout Plain Layout

xLinesAxis.setFontColor("green");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/axes_options_example2.png

\end_inset


\end_layout

\begin_layout Standard
Notice the upper value is aligned on a micro tick, the lower one is aligned
 on a major tick.
\end_layout

\begin_layout Subsubsection
Labels
\end_layout

\begin_layout Standard
The Axis class provides default labels : they correspond to the actual value
 on the axis.
 But you can also provide your own labels.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void addLabel(double forValue, String text)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This method customizes the label for the given forValue.
 Example : 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

String[] labels = new String[]{"January","February","March","April","May","June"
,"July","August","September","October","November","December"};
\end_layout

\begin_layout Plain Layout

for (int i = 0; i < labels.length; i++) { 
\end_layout

\begin_layout Plain Layout

	xColumnsAxis.addLabel(i+1,labels[i]);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For each integer value on the X axis, we set the label to the corresponding
 month.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/axes_labelsexample1.png

\end_inset


\end_layout

\begin_layout Standard
We could have done it as easily with the following method, which only adds
 labels for integer values, in the given order.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void addLabels(String[] labels)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example : 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

String[] labels = new String[]{"January","February","March","April","May","June"
,"July","August","September","October","November","December"};
\end_layout

\begin_layout Plain Layout

xColumnsAxis.addLabels(labels);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The above example will have exactly the same effect as the previous one.
\end_layout

\begin_layout Standard
These methods only converts the given value/label couple into an AxisLabel
 object.
\end_layout

\begin_layout Standard
You can also use the AxisLabel object directly: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public List<AxisLabel> getDiscreteLabels(){
\end_layout

\begin_layout Plain Layout

	List<AxisLabel> labels = new ArrayList<AxisLabel>(); 
\end_layout

\begin_layout Plain Layout

	labels.add(new AxisLabel("Zero",0)); 
\end_layout

\begin_layout Plain Layout

	labels.add(new AxisLabel("Max",10)); 
\end_layout

\begin_layout Plain Layout

	labels.add(new AxisLabel("Min",-10)); 
\end_layout

\begin_layout Plain Layout

	return labels; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

xLinesAxis.addLabels(getDiscreteLabels());
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/axes_labelsexample2.png

\end_inset


\end_layout

\begin_layout Section
Series 
\end_layout

\begin_layout Standard
Series are used to define chart data.
 It is basically a wrapper for a List, which adds specific options to customize
 the serie's rendering.
 
\end_layout

\begin_layout Subsection
Simple serie customization example 
\end_layout

\begin_layout Standard
This example shows how the series rendering can be customized.
 The options will be detailed in the next section.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Serie<Integer> serie1 = new Serie<Integer>(getSampleUniDimensionalData());
\end_layout

\begin_layout Plain Layout

serie1.setMaxDisplayed(3.);
\end_layout

\begin_layout Plain Layout

serie1.setMinDisplayed(0.);
\end_layout

\begin_layout Plain Layout

serie1.setStrokeColor("red");
\end_layout

\begin_layout Plain Layout

serie1.setStrokeWidth(2);
\end_layout

\begin_layout Plain Layout

serie1.setMarkerType(Serie.MARKER_TYPE_CIRCLE);
\end_layout

\begin_layout Plain Layout

Serie<Integer> serie2 = new Serie<Integer>(getSampleUniDimensionalData2());
\end_layout

\begin_layout Plain Layout

serie2.setStrokeColor("blue");
\end_layout

\begin_layout Plain Layout

serie2.setStrokeWidth(2);
\end_layout

\begin_layout Plain Layout

serie2.setMarkerType(Serie.MARKER_TYPE_SQUARE);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/serie_example1.png

\end_inset


\end_layout

\begin_layout Subsection
Series and data
\end_layout

\begin_layout Standard
This section will explain how to add data to a Serie.
 First, you need to create a Serie.
 Serie is a generic type, parametrized with the type of data it can contain.
 
\end_layout

\begin_layout Standard
There are three constructors available for Series :
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public Serie(); 
\end_layout

\begin_layout Plain Layout

public Serie(String name);
\end_layout

\begin_layout Plain Layout

public Serie(List<T> data);
\end_layout

\begin_layout Plain Layout

public Serie(List<T> data, String name);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The data argument is used to initialize the Serie.
 Else, it will be empty and you will have to add data manually.
 The name argument is used when building a Legend.
 See the Legend widget documentation.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Serie<Integer> serie1 = new Serie<Integer>();
\end_layout

\begin_layout Plain Layout

Serie<Double> serie2 = new Serie<Double>(myListOfDouble);
\end_layout

\begin_layout Plain Layout

Serie<Double> serie3 = new Serie<Point>(myListOfPoint,'Gross Profit');
\end_layout

\end_inset

 The types used for data depends on the type of Plot.
 
\end_layout

\begin_layout Itemize
Number can be used for Plot2D, BarPlot, PiePlot 
\end_layout

\begin_layout Itemize
PiePiece can be used for PiePlot only 
\end_layout

\begin_layout Itemize
Point can be used for Plot2D
\end_layout

\begin_layout Itemize
Bubble can be used for BubblePlot
\end_layout

\begin_layout Standard
The data is stored in a List in the Serie object.
 If you want to add data to the Serie, you have to get this list with the
 following method :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public List<T> getData()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alternatively, you can use the delegate methods :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void addData(T o)
\end_layout

\begin_layout Plain Layout

public void addData(int index , T o)
\end_layout

\begin_layout Plain Layout

public void removeData(T o)
\end_layout

\begin_layout Plain Layout

public void removeData(int index)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Series Options 
\end_layout

\begin_layout Standard
The Serie offers several methods to customize its rendering.
\end_layout

\begin_layout Description
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

public void setFillColor(String color)
\end_layout

\end_inset

: Fills the serie with the given color.
 It may the area for a line chart, or the columns/bars for a bar chart etc...
 
\end_layout

\begin_layout Description
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

public void setStrokeColor(String color) 
\end_layout

\end_inset

: Sets the color of the lines.
 
\end_layout

\begin_layout Description
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

public void setStrokeWidth(int width)
\end_layout

\end_inset

: Defines the lines width.
\end_layout

\begin_layout Description
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

public void setMarkerType(String marker)
\end_layout

\end_inset

: Defines the Marker Type.
 The marker argument can be any SVG path, but the Serie class provides constants
 for a few markers :
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final public static String MARKER_TYPE_CIRCLE= "m-3,0 c0,-4 6,-4 6,0 m-6,0
 c0,4 6,4 6,0";
\end_layout

\begin_layout Plain Layout

final public static String MARKER_TYPE_SQUARE= "m-3,-3 l0,6 6,0 0,-6 z";
 
\end_layout

\begin_layout Plain Layout

final public static String MARKER_TYPE_DIAMOND= "m0,-3 l3,3 -3,3 -3,-3 z";
\end_layout

\begin_layout Plain Layout

final public static String MARKER_TYPE_CROSS= "m0,-3 l0,6 m-3,-3 l6,0";
\end_layout

\begin_layout Plain Layout

final public static String MARKER_TYPE_X= "m-3,-3 l6,6 m0,-6 l-6,6";
\end_layout

\begin_layout Plain Layout

final public static String MARKER_TYPE_TRIANGLE= "m-3,3 l3,-6 3,6 z";
\end_layout

\begin_layout Plain Layout

final public static String MARKER_TYPE_TRIANGLE_INVERTED= "m-3,-3 l3,6 3,-6
 z"; 
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

public void setMaxDisplayed(double max)
\end_layout

\end_inset

: Sets the Max displayed value for this Serie.
\end_layout

\begin_layout Description
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

public void setMinDisplayed(double min)
\end_layout

\end_inset

: Sets the Min displayed value for this Serie.
 
\end_layout

\begin_layout Section
Themes 
\end_layout

\begin_layout Standard
Dojo offers a few Themes for charting.
\end_layout

\begin_layout Standard
Those permits to use default colors.
 
\end_layout

\begin_layout Standard
You can choose to use a theme with the method Chart2D.setTheme: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void setTheme(String theme)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Where theme is a constant defined in the Themes class.
\end_layout

\begin_layout Standard
Example : 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

chart.setTheme(Themes.Shrooms);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/theme_shrooms.png

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

chart.setTheme(Themes.Tufte); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/theme_tufte.png

\end_inset


\end_layout

\begin_layout Standard
The chart, axis, and Series options are exactly the same on the two charts.
\end_layout

\begin_layout Standard
The only thing which has changed is the Theme.
\end_layout

\begin_layout Section
Effects
\end_layout

\begin_layout Standard
You can add nice animations and event listeners to your chart.
 These effects are located in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

com.objetdirect.tatami.charting.effects
\end_layout

\end_inset

 package, and inherit the Effect interface.
 Effects are added to the Plot object thanks to the plot.addEffect method
 :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void addEffect(Effect effect)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will review the available effects, and explain how to implement a ChartEventL
istener
\end_layout

\begin_layout Subsection
Commons Options
\end_layout

\begin_layout Standard
Most effects have the duration option, which can be set at construction
 time or with the associated setter.
 It modifies the animation duration, in milliseconds.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void setDuration(int duration); 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
EffectTooltip 
\end_layout

\begin_layout Standard
The corresponding class is 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

com.objetdirect.tatami.client.charting.effects.EffectTooltip 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The basic Tooltip effect will show the point (or slice/bar/column/bubble...)
 value in a tooltip.
\end_layout

\begin_layout Standard
Example : 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

plot.addEffect(new EffectTooltip());
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But the Point, Bubble and PiePiece data objects each offer a way to give
 a custom tooltip to the data.
 They implement the HasTooltip interface: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package com.objetdirect.tatami.client.charting;
\end_layout

\begin_layout Plain Layout

public interface HasTooltip {
\end_layout

\begin_layout Plain Layout

	public String getTooltip(); 
\end_layout

\begin_layout Plain Layout

	public void setTooltip(String tooltip); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Moreover, they each have a constructor taking this tooltip into account
 :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public Bubble(double x, double y ,double size,String tooltip)
\end_layout

\begin_layout Plain Layout

public Point(double x, double y , String tooltip)
\end_layout

\begin_layout Plain Layout

public PiePiece(double value , String label,String color, String fontColor,
 String tooltip)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Point[] points = new Point[]{new Point(0.3,8.0),new Point(4.,6.,"Custom tooltip"),ne
w Point(5.5,2.)};
\end_layout

\begin_layout Plain Layout

Serie<Point> serie = new Serie<Point>(Arrays.asList(points2), "Serie 2");
\end_layout

\begin_layout Plain Layout

plot.addSerie(serie);
\end_layout

\begin_layout Plain Layout

plot.addEffect(new EffectTooltip());
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/effects_tooltip.png

\end_inset


\end_layout

\begin_layout Subsection
EffectHighlight 
\end_layout

\begin_layout Standard
This effect highlights the chart element under mouse :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

plot.addEffect(new EffectHighlight());
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/effect_highlightexampl1.png

\end_inset


\end_layout

\begin_layout Standard
The default behavior is this one, but you can chang the highlighting color
 :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public EffectHighlight(String color)
\end_layout

\begin_layout Plain Layout

public void setColor(String color)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

plot.addEffect(new EffectHighlight("gold"));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will produce the following effect :
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/effect_highlightexampl2.png

\end_inset


\end_layout

\begin_layout Subsection
EffectShake 
\end_layout

\begin_layout Standard
This effect has no other option than the common “duration” option.
 It will shake the chart element under mouse.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

plot.addEffect(new EffectShake());
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
EffectMagnify 
\end_layout

\begin_layout Standard
This effect magnifies the chart element under mouse.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

plot.addEffect(new EffectMagnify());
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It has a « scale » parameter which specifies the magnifying ratio.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public EffectMagnify(double scale);
\end_layout

\begin_layout Plain Layout

setScale(double scale)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example for scale=2 : 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/effects_magnify.png

\end_inset


\end_layout

\begin_layout Subsection
EffectMoveSlice : 
\end_layout

\begin_layout Standard
This effect can only be added to a PiePlot.
 It moves the PieSlice away from the center.
 It has no other options than the common duration.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

PiePlot<PiePiece> plot = new PiePlot<PiePiece>();
\end_layout

\begin_layout Plain Layout

plot.addEffect(new EffectMoveSlice()); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/chartingimages/pieplot_effect.png

\end_inset


\end_layout

\begin_layout Subsection
PlotListener :
\end_layout

\begin_layout Subsubsection
API description
\end_layout

\begin_layout Standard
You can add your own listener to chart event.
 To do so, extend the PlotMouseListener class.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

PlotMouseListener listener = new PlotMouseListener() {
\end_layout

\begin_layout Plain Layout

	public void processEvent(EffectEvent event) {
\end_layout

\begin_layout Plain Layout

		//Process event as you wish 
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The EffectEvent contains chart specific events.
\end_layout

\begin_layout Standard
It provides several methods describing the event.
\end_layout

\begin_layout Description
getType(): This method returns the type of the event.
 It will return one of the following constants : 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final public static String TYPE_ONCLICK = "onclick";
\end_layout

\begin_layout Plain Layout

final public static String TYPE_ONMOUSEOVER = "onmouseover";
\end_layout

\begin_layout Plain Layout

final public static String TYPE_ONMOUSEOUT = "onmouseout";
\end_layout

\end_inset


\end_layout

\begin_layout Description
getElementType(): This method returns the type of the element which fired
 the event.
 It will return one of the following constants :
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final public static String ELEMENT_TYPE_MARKER = "marker";
\end_layout

\begin_layout Plain Layout

final public static String ELEMENT_TYPE_BAR = "bar";
\end_layout

\begin_layout Plain Layout

final public static String ELEMENT_TYPE_COLUMN = "column";
\end_layout

\begin_layout Plain Layout

final public static String ELEMENT_TYPE_CIRCLE = "circle";
\end_layout

\begin_layout Plain Layout

final public static String ELEMENT_TYPE_SLICE = "slice"; 
\end_layout

\end_inset


\end_layout

\begin_layout Description
getX(): this method returns the x-coordinate of the point which fired the
 event.
\end_layout

\begin_layout Description
getY(): this method returns the y-coordinate of the point which fired the
 event.
\end_layout

\begin_layout Description
getAssociatedObject(): It will return a representation of the element.
 This representation is : 
\end_layout

\begin_layout Itemize
a PiePiece object if the element which fired the event was a slice
\end_layout

\begin_layout Itemize
a Point object if the element which fired the event was a marker
\end_layout

\begin_layout Itemize
a Bubble object if the element which fired the event was a circle
\end_layout

\begin_layout Itemize
a Double if the element which fired the event was a Bar or a column
\end_layout

\begin_layout Subsubsection
Example/Tutorial 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

FlowPanel panel = new FlowPanel();
\end_layout

\begin_layout Plain Layout

panel.setStylePrimaryName("testChartCustomEffectPage-chartAndLabelsContainer");
\end_layout

\begin_layout Plain Layout

Chart2D chart = new Chart2D("300px","300px");
\end_layout

\begin_layout Plain Layout

PiePlot<PiePiece> plot = new PiePlot<PiePiece>();
\end_layout

\begin_layout Plain Layout

final HTML onMouseOver = new HTML();
\end_layout

\begin_layout Plain Layout

final HTML onMouseClick = new HTML();
\end_layout

\begin_layout Plain Layout

final HTML onMouseOut = new HTML();
\end_layout

\begin_layout Plain Layout

Serie<PiePiece> serie1 = new Serie<PiePiece>();
\end_layout

\begin_layout Plain Layout

serie1.setName("continents");
\end_layout

\begin_layout Plain Layout

serie1.addData(new PiePiece(30370000,"Africa","#FFFFFF"));
\end_layout

\begin_layout Plain Layout

serie1.addData(new PiePiece(42330000,"America"));
\end_layout

\begin_layout Plain Layout

serie1.addData(new PiePiece(13720000,"Antarctica"));
\end_layout

\begin_layout Plain Layout

serie1.addData(new PiePiece(43810000 ,"Asia"));
\end_layout

\begin_layout Plain Layout

serie1.addData(new PiePiece(9010000,"Australia"));
\end_layout

\begin_layout Plain Layout

serie1.addData(new PiePiece(10180000,"Europe"));
\end_layout

\begin_layout Plain Layout

plot.addEffect(new EffectTooltip());
\end_layout

\begin_layout Plain Layout

PlotMouseListener listener = new PlotMouseListener() {
\end_layout

\begin_layout Plain Layout

	public void processEvent(EffectEvent event) { 
\end_layout

\begin_layout Plain Layout

		String label ="";
\end_layout

\begin_layout Plain Layout

		if(EffectEvent.ELEMENT_TYPE_SLICE.equals(event.getElementType())){
\end_layout

\begin_layout Plain Layout

			label = ((PiePiece)event.getAssociatedObject()).getLabel();
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if(event.getType().compareTo(EffectEvent.TYPE_ONCLICK) == 0){
\end_layout

\begin_layout Plain Layout

			onMouseClick.setHTML("Clicked on : " + label);
\end_layout

\begin_layout Plain Layout

		}else if(event.getType().compareTo(EffectEvent.TYPE_ONMOUSEOVER) == 0){
\end_layout

\begin_layout Plain Layout

			onMouseOver.setHTML("Mouse Over : " + label); 
\end_layout

\begin_layout Plain Layout

		}else if(event.getType().compareTo(EffectEvent.TYPE_ONMOUSEOUT) == 0){
\end_layout

\begin_layout Plain Layout

			onMouseOut.setHTML("Mouse Out : " + label); 
\end_layout

\begin_layout Plain Layout

		} 
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}; 
\end_layout

\begin_layout Plain Layout

plot.addEffect(listener); 
\end_layout

\begin_layout Plain Layout

plot.addSerie(serie1);
\end_layout

\begin_layout Plain Layout

chart.addPlot(plot);
\end_layout

\begin_layout Plain Layout

DOM.setElementAttribute(chart.getElement(),"id","chart1");
\end_layout

\begin_layout Plain Layout

DOM.setElementAttribute(onMouseOver.getElement(),"id","chart1MouseOver");
 DOM.setElementAttribute(onMouseClick.getElement(),"id","chart1MouseClick");
 DOM.setElementAttribute(onMouseOut.getElement(),"id","chart1MouseOut");
\end_layout

\begin_layout Plain Layout

panel.add(chart);
\end_layout

\begin_layout Plain Layout

panel.add(onMouseClick);
\end_layout

\begin_layout Plain Layout

panel.add(onMouseOver); 
\end_layout

\begin_layout Plain Layout

panel.add(onMouseOut);
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Drag And Drop Features
\end_layout

\begin_layout Section
YUI Drag And Drop
\end_layout

\begin_layout Standard
The drag-and-drop component is a panel in which widgets are allowed to be
 … dragged and dropped.
 Any kind of widget can be used, the panel is entirely responsible for adding
 the drag an drop capability
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/dnd_yuiexample.png

\end_inset

.
\end_layout

\begin_layout Standard
The drag-and-drop component relies on the following concepts: 
\end_layout

\begin_layout Itemize
The capacity for a widget to be dragged
\end_layout

\begin_layout Itemize
The capacity for a widget to be a drop target
\end_layout

\begin_layout Itemize
The compatibility between the dragged component and the component on which
 it is dropped.
 
\end_layout

\begin_layout Standard
The compatibility tells whether a (dragged) widget can be dropped on another
 one (the target).
 The first widget has to be declared as a draggable widget to the panel
 for the given compatibility, and the other widget has to be declared as
 a target for the same compatibility.
 A compatibility is just a string.
\end_layout

\begin_layout Standard
A given widget can be draggable and a target at the same time.
 It can be involved in more than one compatibility rule.
 For instance, a widget w1 could be target for a widget w2 according to
 the compatibility “comp1”, and w1 could also be dropped on yet another
 widget w3 according to the compatibility “comp2”.
 The code corresponding to this example is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
DragAndDropPanel ddPanel = new DragAndDropPanel();
\end_layout

\begin_layout Plain Layout
Widget w1 = 
...

\lang english
 
\end_layout

\begin_layout Plain Layout
Widget w2 = 
...
\end_layout

\begin_layout Plain Layout
Widget
 
\lang english
w3 = 
...

\lang english
 
\end_layout

\begin_layout Plain Layout
ddPanel.addTargetWidget(w1, 50, 50, "aff1");
\end_layout

\begin_layout Plain Layout
ddPanel.addDraggableWidget(w2, 100, 100, "aff1");
\end_layout

\begin_layout Plain Layout
ddPanel.setDraggable(w1, "aff2");
\end_layout

\begin_layout Plain Layout
ddPanel.addTargetWidget(w3, 50, 50, "aff2");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If a draggable widget happens to be dropped on a target widget (or on a
 non-target widget, or on nothing) with which it shares no compatibility
 at all, the dragged widget goes back to its original position.
\end_layout

\begin_layout Standard
This system is quite flexible and allows about any combination: 
\end_layout

\begin_layout Itemize
A widget can be draggable and target for the same compatibility, or for
 different compatibilities.
\end_layout

\begin_layout Itemize
A widget can be draggable or target of several compatibilities.
 
\end_layout

\begin_layout Itemize
A widget can be added or removed compatibilities dynamically (specifying
 each time if the compatibility is relative to a draggable capacity or a
 target capacity).
\end_layout

\begin_layout Itemize
A widget for which all compatibilities have been removed will no longer
 be movable.
\end_layout

\begin_layout Standard
Note that the drag-and-drop panel can contain widgets which are neither
 targets nor draggable.
\end_layout

\begin_layout Standard
Drag and drop operations produce events which can be handled programmatically.
 It is even possible to block a move when compatibility rules are satisfied.
 Events are dispatched to objects implementing DragAndDropListener interface,
 and registered in the panel.
 The next section of this document presents this interface in details.
\end_layout

\begin_layout Subsection
Building a simple drag-and-drop component
\end_layout

\begin_layout Standard
This part is a mini tutorial on main APIs available for the drag-and-drop
 component.
 Let’s begin with the instantiation of a drag-and-drop panel:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
import com.objetdirect.tatami.client.DragAndDropPanel;
\end_layout

\begin_layout Plain Layout
DragAndDropPanel ddPanel = new DragAndDropPanel();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This panel can then be resized to the required space for drag and drop operation
s, and attached somewhere in the GWT component tree:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
ddPanel.setSize("500px", "400px");
\end_layout

\begin_layout Plain Layout
RootPanel.get().add(ddPanel, 0, 0);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A draggable widget can be added via the addDraggableWidget method as illustrated
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
Image romeo = new Image("romeo.png");
\end_layout

\begin_layout Plain Layout
ddPanel.addDraggableWidget(romeo, 50, 50, "romeo&juliet");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The upper left border of the Romeo picture is at position 50, 50.
 Romeo is compatible with “romeo&Juliet”.
\end_layout

\begin_layout Standard
The Romeo widget can be moved, but any drop leads to a return to its original
 position for there are no compatible target with “romeo&Juliet” so far.
\end_layout

\begin_layout Standard
Let’s create the Juliet widget and declare it as a possible target for Romeo.
 The method addTargetWidget should be used for that purpose:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
Image juliet = new Image("juliet.png");
\end_layout

\begin_layout Plain Layout
ddPanel.addTargetWidget(juliet, 250, 50, "romeo&juliet");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now you can try to move Romeo onto Juliet: this time Romeo will not return
 back to its original position.
 It stays with Juliet.
 However, Juliet does not move at all.
\end_layout

\begin_layout Standard
Let’s try now with two new pictures of Tristan and Iseult:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
Image tristan = new Image("tristan.png");
\end_layout

\begin_layout Plain Layout
ddPanel.addDraggableWidget(tristan, 50, 250, "tristan&iseult");
\end_layout

\begin_layout Plain Layout
Image iseult = new Image("iseult.png");
\end_layout

\begin_layout Plain Layout
ddPanel.addTargetWidget(iseult, 250, 250, "tristan&iseult");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, Romeo can still be dropped on Juliet, but not on Iseult, and conversely
 for Tristan.
\end_layout

\begin_layout Standard
We are going to create a new picture, named Dom Juan, which is able to join
 any “feminine” widget.
 Therefore it is a draggable widget, compatible with both “romeo&Juliet”
 and "tristan&iseult".
 The method addDraggableWidget will be used for declaring Dom Juan compatible
 with “romeo&Juliet” and add it to the panel.
 The next step consists in invoking setDraggable to provide Dom Juan with
 the "tristan&iseult" compatibility:
\end_layout

\begin_layout Standard
I
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
mage domjuan = new Image("domjuan.png");
\end_layout

\begin_layout Plain Layout
ddPanel.addDraggableWidget(domjuan, 50, 450, "romeo&juliet");
\end_layout

\begin_layout Plain Layout
ddPanel.setDraggable(domjuan, "tristan&iseult");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now Dom Juan can be dropped either on Juliet as well as on Iseult.
 However, Dom Juan would not accept to be dropped on Romeo nor Tristant,
 as those widgets are not declared as targets.
\end_layout

\begin_layout Standard
Unfortunately, Iseult and Juliet can not by themselves join their lovers.
 We are going to improve this by declaring Romeo and Tristan as target widgets,
 and Juliet and Iseult as draggable widgets.
\end_layout

\begin_layout Standard
For that purpose, the setDraggable method (we already know) will be used
 and its target analogous, setTarget.
 Those methods can provide both capacities (draggable and target) to the
 same widget:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
ddPanel.setDraggable(juliet, "romeo&juliet");
\end_layout

\begin_layout Plain Layout
ddPanel.setDraggable(iseult, "tristan&iseult");
\end_layout

\begin_layout Plain Layout
ddPanel.setTarget(romeo, "romeo&juliet");
\end_layout

\begin_layout Plain Layout
ddPanel.setTarget(tristan, "tristan&iseult");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Moreover, the setTarget method can be used to add more than one target compatibi
lity to the same widget.
 For the purpose of illustration, and simplifying at the same time Dom Juan
 coding, we will add the “woman” compatibility to all female widgets.
 Then Dom Juan will just have to be draggable for that compatibility:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
ddPanel.setTarget(juliet, "woman");
\end_layout

\begin_layout Plain Layout
ddPanel.setTarget(iseult, "woman");
\end_layout

\begin_layout Plain Layout
Image domjuan = new Image("domjuan.png");
\end_layout

\begin_layout Plain Layout
ddPanel.addDraggableWidget(domjuan, 50, 450, "woman");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now let’s see it is possible to add widgets which are neither draggable
 nor targets:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
Image tintin = new Image("tintin.png");
\end_layout

\begin_layout Plain Layout
ddPanel.add(tintin, 450, 450);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A widget, whatever its status with respect to the Drag-and-drop capabilities,
 can always be moved with the method setWidgetPosition.
 In that case, the compatibility is not checked and the move is done in
 any case.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
ddPanel.setWidgetPosition(tintin, 500, 500);
\end_layout

\end_inset

 Actually, the DragAndDropPanel is a subclass of AbsolutePanel, and as such
 all methods available on the latter class are also available for the former
 safely.
 
\end_layout

\begin_layout Subsection
Receiving and handling drag and drop events 
\end_layout

\begin_layout Standard
When a drag and drop event has been accepted by the panel, i.e.
 the compatibilities between the source and the target widget are in corresponde
nce, this event can of course be intercepted.
 When the two widgets are not compatible, the dragged widget returns back
 to its original location without any event being triggered.
 A drop event can even be rejected when the panel has already accepted it.
\end_layout

\begin_layout Standard
The handling of drag and drop events requires an object which implements
 the DragAndDropListener interface.
 The following two methods shall be implemented:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
public boolean acceptDrop(Widget draggable, Widget target) { … } 
\end_layout

\begin_layout Plain Layout
public void onDrop(Widget draggable, Widget target) { … }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The acceptDrop method tells whether the drag and drop operation has been
 agreed for.
 The onDrop method is called when the drag and drop operation has definitely
 been accepted.
 This is the method where the event can be handled.
\end_layout

\begin_layout Standard
Both methods receive the dragged and the target widget involved in the operation.
 The method addDragDropListener of the panel allows the registering of a
 drag and drop listener.
 The removing of a listener can be done via the removeDragDropListener method.
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
DragAndDropListener listener = new DragAndDropListener() {
\end_layout

\begin_layout Plain Layout
	public void onDrop(Widget draggable, Widget target) { … }
\end_layout

\begin_layout Plain Layout
	public boolean acceptDrop(Widget draggable, Widget target) { return true;
 }
\end_layout

\begin_layout Plain Layout
};
\end_layout

\begin_layout Plain Layout
ddpPanel.addDragDropListener(listener); 
\end_layout

\begin_layout Plain Layout
… ddpPanel.removeDragDropListener(listener);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Adding and removing compatibilities 
\end_layout

\begin_layout Standard
A compatibility (either draggable or target) can be added and removed at
 any time.
 Whenever a widget loses all its compatibilities, it can no longer be a
 target or draggable, according to the compatibility type.
 For instance, a widget for which all draggable compatibilities has been
 removed can no longer be moved.
\end_layout

\begin_layout Standard
The method unsetDraggable of the panel can be used to remove a draggable
 capability to a widget:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
public void unsetDraggable(Widget widget, String affordance); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The method unsetTarget of the panel can be used to remove a target compatibility
 to a widget:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
public void unsetTarget(Widget widget, String affordance);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All compatibilities of the same capacity can be removed in one operation.
 Methods with the same names as the afore mentioned ones are available for
 that purpose, with the second parameter being discarded.
\end_layout

\begin_layout Standard
For instance the method:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
public void unsetDraggable(Widget widget);
\end_layout

\end_inset

 removes the draggable capability for the widget, and the method:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
public void unsetTarget(Widget widget);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
removes the target capability for the widget.
\end_layout

\begin_layout Subsection
Getting information from the drag-and-drop panel
\end_layout

\begin_layout Standard
More methods are available on the drag-and-drop panel which give access
 to information relative its contents.
\end_layout

\begin_layout Standard
The isDraggable method tells whether a widget is draggable (i.e.
 for at least one compatibility):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
public boolean isDraggable(Widget widget);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The hasDraggableAffordance method tells whether a given widget is draggable
 for a given compatibility: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
public boolean hasDraggableAffordance( Widget widget, String affordance);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The getDraggableAffordances method returns the list of all draggable compatibili
ties for a given widget (the compatibilities relative to the target capacity
 of the widget, if any, are not in that list):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
public String[] getDraggableAffordances(Widget widget);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The getDraggableAffordanceSet method return the list of draggable widgets
 for the given compatibility:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
public Widget[] getDraggableAffordanceSet(String affordance); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Similar methods are available for the target capacity.
 The isTarget method tells whether a given widget is a target (i.e.
 for at least one compatibility):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
public boolean isTarget(Widget widget);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The hasTargetAffordance method tells whether a given widget is a target
 for a given compatibility:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
public boolean hasTargetAffordance( Widget widget, String affordance);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The getTargetAffordances methods returns the list of all target compatibilities
 for a given widget ((the compatibilities relative to the draggable capacity
 of the widget, if any, are not in that list):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
public String[] getTargetAffordances(Widget widget);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The getTargetAffordanceSet method returns the list of target widgets for
 the given compatibility:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
public Widget[] getTargetAffordanceSet(String affordance); 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Dojo Drag And Drop
\end_layout

\begin_layout Standard
Dojo drag and drop provides a powerful mechanism to perform drag and drop.
 It introduces the following concepts:
\end_layout

\begin_layout Itemize
A DND source is a widget which contains movable elements, which are called
 DNDElement
\end_layout

\begin_layout Itemize
A DND target is a widget which will potentially accept dropped DNDElement
\end_layout

\begin_layout Itemize
A DNDElement is a movable object, within a DND source
\end_layout

\begin_layout Itemize
A DNDBehavior process drag and drop events for a given list of source-target
 couples.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/dndExample1.jpg

\end_inset


\end_layout

\begin_layout Subsection
Getting Started
\end_layout

\begin_layout Standard
We will demonstrate a simple DnD use.
 This example will define a DnDSource, a DnDTarget and add some behaviours
 to those.
\end_layout

\begin_layout Subsubsection
Defining the Source
\end_layout

\begin_layout Standard
First, we define a drag and drop source.
 There are two DNDSource types in tatami:
\end_layout

\begin_layout Itemize
WidgetSource: they are constructed from a Panel, and allow any Widget to
 be dragged.
\end_layout

\begin_layout Itemize
TreeSource: they allow tree items to be dragged and to accept drop events.
\end_layout

\begin_layout Standard
But you do not have to construct these objects yourself, since the DnD helper
 do all this for you.
 
\end_layout

\begin_layout Standard
We begin by defining a standard GWT panel, and adding widgets to it :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

VerticalPanel sourcePanel = new VerticalPanel();
\end_layout

\begin_layout Plain Layout

HTML widget1 = new HTML("I can be dragged");
\end_layout

\begin_layout Plain Layout

HTML widget2 = new HTML("I can be dragged too");
\end_layout

\begin_layout Plain Layout

sourcePanel.add(widget1);
\end_layout

\begin_layout Plain Layout

sourcePanel.add(widget2);
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, we register this panel as a source panel, and the widgets it contains
 as dnd element within these source.
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
DnD.registerSource(sourcePanel);
\end_layout

\begin_layout Plain Layout
DnD.registerElement(sourcePanel,widget1);
\end_layout

\begin_layout Plain Layout
DnD.registerElement(sourcePanel,widget2);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We are now able to move widget1 and widget2 across the screen, but nobody
 is there to accept them.
\end_layout

\begin_layout Subsubsection
Defining the Target
\end_layout

\begin_layout Standard
Similarly,we will define a DnD Target.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

VerticalPanel targetPanel = new VerticalPanel();
\end_layout

\begin_layout Plain Layout

HTML widget3 = new HTML("I cannot be dragged");
\end_layout

\begin_layout Plain Layout

HTML widget4 = new HTML("Me neither"); 
\end_layout

\begin_layout Plain Layout

targetPanel.add(widget3);
\end_layout

\begin_layout Plain Layout

targetPanel.add(widget4);
\end_layout

\begin_layout Plain Layout

DnD.registerTarget(targetPanel);
\end_layout

\begin_layout Plain Layout

DnD.registerElement(targetPanel,widget3);
\end_layout

\begin_layout Plain Layout

DnD.registerElement(targetPanel,widget4);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Defining a behavior
\end_layout

\begin_layout Standard
Now we must define a behavior to be applied to those drag and drop events.
\end_layout

\begin_layout Standard
There are some Behavior classes defined.
 See the behavior section for a complete description of each.
\end_layout

\begin_layout Standard
Here, we will use the WidgetDnDBehavior, which is the best suited to manage
 dragging a widget from one panel to another.
\end_layout

\begin_layout Standard
We will override the onDrop method only, to move the dropped widget from
 the source to the target.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
WidgetDnDBehavior myBehavior = new DnDDefaultWidgetBehavior() { 
\end_layout

\begin_layout Plain Layout
	@Override 
\end_layout

\begin_layout Plain Layout
	public boolean onDrop(Collection<Widget> draggedWidgets, Panel source,
 Panel target, String targetNodeId, boolean isCopy) {
\end_layout

\begin_layout Plain Layout
		for (Widget widget : draggedWidgets) {
\end_layout

\begin_layout Plain Layout
			DnD.move(widget, source, target);
\end_layout

\begin_layout Plain Layout
		} 
\end_layout

\begin_layout Plain Layout
		return true;
\end_layout

\begin_layout Plain Layout
	}
\end_layout

\begin_layout Plain Layout
};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, we register this behavior for our specifics sources and target:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
try { 
\end_layout

\begin_layout Plain Layout
	DnD.registerBehavior(myBehavior, sourcePanel, targetPanel);
\end_layout

\begin_layout Plain Layout
} catch (BehaviorScopeException e) {
\end_layout

\begin_layout Plain Layout
}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Registering a behavior for a source/target couple may raise an exception
 if a behavior is already defined for these couple.
\end_layout

\begin_layout Standard
Now, we are able to drag a widget from the source panel to the target:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/dndSimple.png

\end_inset


\end_layout

\begin_layout Standard
You may also drag both draggable items by clicking them s
\end_layout

\begin_layout Subsection
DndSources
\end_layout

\begin_layout Standard
A dnd source acts as a container for Dnd elements.
 It is registered to an associated DnDController, which is designed to manage
 this particular type of source.
 
\end_layout

\begin_layout Standard
Tatami currently provides two types of dnd sources : 
\end_layout

\begin_layout Itemize
WidgetSource: they are constructed from a Panel, and allow any Widget to
 be dragged.
\end_layout

\begin_layout Itemize
TreeSource: they allow tree items to be dragged and to accept drop events.
\end_layout

\begin_layout Standard
You normally do not have to instantiate those objects yourself, but you
 will be able to manipulate them when using a DnDBehavior.
\end_layout

\begin_layout Standard
If you want to use a widgetSource, just use the following method
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
DnD.registerSource(Panel panel);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, you can add register widgets contained in this panel as DndElement:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
DnD.registerElement(
Panel
\lang english
,
Widget
\lang english
);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you want to use a TreeSource, use the following method:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
DnD.registerTreeSource(
Tree
\lang english
);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You do not have to register any DndElement for a tree, since all TreeItems
 are necessarily DnDElement in a tree registered as a tree source.
\end_layout

\begin_layout Subsection
DndTarget
\end_layout

\begin_layout Standard
A DndTarget is defined as a container wich may accept drop operations
\end_layout

\begin_layout Standard
A DndTarget is registered with one of the following methods:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
DnD.registerTarget(Tree);
\end_layout

\begin_layout Plain Layout
DnD.registerTarget(Panel);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Respectively, for a panel or a tree.
\end_layout

\begin_layout Subsection
DnDBehavior
\end_layout

\begin_layout Standard
A DndBehavior is responsible for processing drag and drop events from a
 set of sources to a set of target.
\end_layout

\begin_layout Subsubsection
IDnDBehavior interface
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface IDnDBehavior<E extends IDnDElement , S extends IDnDSource<?>
 , T extends IDnDTarget> {
\end_layout

\begin_layout Plain Layout

	public boolean onDrop(Collection<E> dndElements, S source, T target, String
 targetNodeId , boolean isCopy ); 
\end_layout

\begin_layout Plain Layout

	public void elementsAccepted(S source,T target, Collection<E> elements,
 boolean copied,IDnDController<?, T> controller); 
\end_layout

\begin_layout Plain Layout

	public void dragOver(IDnDTarget target); 
\end_layout

\begin_layout Plain Layout

	public boolean checkItemAcceptance(S source , T target , Collection<E>
 dndElements); 
\end_layout

\begin_layout Plain Layout

	public void onDndStart(Collection<E> elementBeingDragged , S source , boolean
 ctrlKey); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This interface is generic: it can be implemented for a particular type of
 DnDElement, a particular type of DnDSource and a particular type of Target.
\end_layout

\begin_layout Standard
That means you will be able to implement a behavior for WidgetDnDElement
 
\end_layout

\begin_layout Standard
Each of those methods are called during the drag and drop process.
\end_layout

\begin_layout Description
onDnDStart: it will be called each time a drag operation is originated from
 one of the sources the behavior has been registered for.
\end_layout

\begin_layout Description
checkItemAcceptance: it will be called to verify that a target will likely
 accept a drop operation from a source, for a given set of elements, when
 the user is dragging any element from one one of the sources the behavior
 has been registered for to a target.
 This will result in UI changes: the drag and drop avatar following the
 mouse will be coloured in red or green according to what has been returned
 from this call.
 
\end_layout

\begin_layout Description
dragOver: it will be called each time the user is dragging an item over
 the registered target
\end_layout

\begin_layout Description
onDrop: it will be called each time the user tries to drop an item from
 a registered source to a registered target
\end_layout

\begin_layout Description
elementsAccepted: it will be called if the onDrop operation returned true.
\end_layout

\begin_layout Subsubsection
AbstractBehavior & DnDGenericBehavior
\end_layout

\begin_layout Standard
Tatami provides two abstract class which makes the IDnDBehavior interface
 more easy to implement
\end_layout

\begin_layout Standard
AbstractDnDBehavior just implements IDnDBehavior with defaults 
\begin_inset Quotes eld
\end_inset

do-nothing
\begin_inset Quotes erd
\end_inset

 implementations.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
public abstract class AbstractDnDBehavior<E extends IDnDElement,S extends
 IDnDSource<? extends E>,T extends IDnDTarget> implements IDnDBehavior<E,
 S, T>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So you can override only the methods you want from the AbstractDnDBehavior.
\end_layout

\begin_layout Standard
Ex:
\end_layout

\begin_layout Chapter
Encoding
\end_layout

\begin_layout Standard
Dojo offers APIs for encoding data in various formats.
 Tatami brings this feature to the GWT world by wrapping those APIs.
 
\end_layout

\begin_layout Section
BlowFish encryption
\end_layout

\begin_layout Standard
BlowFish is a symmetric cipher algorithm, relying on a private key that
 must be shared amongst people wanting to communicates ciphered data.
\end_layout

\begin_layout Standard
Tatami provides a simple API to use the BlowFish algorithm in GWT.
\end_layout

\begin_layout Standard
Sample :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

BlowFishEncryption cipher = BlowFishEncryption.getInstance();
\end_layout

\begin_layout Plain Layout

String key = "the secret key"; 
\end_layout

\begin_layout Plain Layout

String randomString = "this text should remain unrevealed! ";
\end_layout

\begin_layout Plain Layout

String ciphered = cipher.encrypt(BlowFishEncryption.Base64OutputType, randomString
, key); 
\end_layout

\begin_layout Plain Layout

String deciphered = ciher.decrypt(BlowFishEncryption.Base64OutputType, ciphered,
 key); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the above sample, we use a secret key (“the secret key”) to encrypt a
 text.
 Tatami currently support two output-types/input types for the ciphering/deciphe
ring process.
 
\end_layout

\begin_layout Standard
Those are : 
\end_layout

\begin_layout Itemize
Base64 : the output will be encoded in Base64 format.
\end_layout

\begin_layout Itemize
Hex : the output will be encoded in Hex format
\end_layout

\begin_layout Standard
Those formats are defined as constants in the BlowFishEncryption class (respecti
vely BlowFishEncryption.Base64OutputType and BlowFishEncryption.
 HexOutputType)
\end_layout

\begin_layout Standard
While using the BlowFish encryption , you should assure which output format
 comes from the cipher, and which format waits the decipher.
 
\end_layout

\begin_layout Description
getInstance(): Returns an instance of the BlowFishEncryption
\end_layout

\begin_layout Description
encrypt(EncodingTypeConstant
\begin_inset space ~
\end_inset

outputTypeConstant,String
\begin_inset space ~
\end_inset

toCrypt,String
\begin_inset space ~
\end_inset

key): Encrypt the given text using the given key.
 The output format is defined by outputTypeConstant, which can be either
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BlowFishEncryption.Base64OutputType
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BlowFishEncryption.HexOutputType
\end_layout

\end_inset


\end_layout

\begin_layout Description
decrypt(EncodingTypeConstant
\begin_inset space ~
\end_inset

inputTypeConstant,String
\begin_inset space ~
\end_inset

toDecrypt,String key): Decrypt the given text using the given key.
 The input format is defined by inputTypeConstant, which can be either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BlowFishEncryption.Base64OutputType
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BlowFishEncryption.HexOutputType
\end_layout

\end_inset


\end_layout

\begin_layout Section
MD5 hash
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
MD5 has been used for a long time as an asymmetric hash algorithm.
 Tatami gives users a convenient way of achieving MD5 hash.
 
\end_layout

\begin_layout Standard
Sample :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MD5 md5 = MD5.getInstance();
\end_layout

\begin_layout Plain Layout

String text = "text";
\end_layout

\begin_layout Plain Layout

String resultingMD5 = md5.encode(text , MD5.HexOutputType);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resulting md5 will be equal to “1cb251ec0d568de6a929b520c4aed8d1” in
 that case.
 MD5 sum results are usually given in Hexadecimal format (just like above),
 but other output types are defined : 
\end_layout

\begin_layout Description
MD5.Base64OutputType: The result will be encoded in Base64 format MD5
\end_layout

\begin_layout Description
StringOutputType: The result will be encoded as a String representing the
 binary data MD5.
\end_layout

\begin_layout Description
HexOutputType: the result will be encoded in Hexadecimal format
\end_layout

\begin_layout Subsection
API
\end_layout

\begin_layout Description
getInstance(): Returns an instance of the MD5
\end_layout

\begin_layout Description
encode(String
\begin_inset space ~
\end_inset

toEncode,EncodingTypeConstant
\begin_inset space ~
\end_inset

encodingtype): Encode the given text.
 The resulting sum will be encoded according to the specified EncodingTypeConsta
nt.
\end_layout

\end_body
\end_document
